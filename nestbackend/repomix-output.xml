This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
articles/
  dto/
    filter-article.dto.ts
  articles.controller.ts
  articles.module.ts
  articles.service.ts
  filtering.service.ts
structure/
  structure.controller.ts
  structure.module.ts
  structure.service.ts
structure-attributes/
  dto/
    filter-structure-attribute.dto.ts
  filter.service.ts
  structure-attributes.controller.ts
  structure-attributes.module.ts
  structure-attributes.service.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="articles/dto/filter-article.dto.ts">
import { IsOptional, IsString, IsIn } from 'class-validator';
import { Transform } from 'class-transformer';

export class FilterArticleDto {
  @IsOptional()
  @IsString()
  category?: string;

  // Sorting parameters
  @IsOptional()
  @IsString()
  sortBy?: string;

  @IsOptional()
  @IsString()
  @IsIn(['asc', 'desc', 'ASC', 'DESC'])
  @Transform(({ value }) => value?.toLowerCase())
  sortOrder?: 'asc' | 'desc';
}
</file>

<file path="articles/articles.controller.ts">
import { Controller, Get, Post, Body, Patch, Param, Delete, UseGuards, Query } from '@nestjs/common';
import { ArticlesService } from './articles.service';
import { Prisma } from '@prisma/client';
import { AuthGuard } from '@nestjs/passport';
import { FilterArticleDto } from './dto/filter-article.dto';
@Controller('articles')
export class ArticlesController {
  constructor(private readonly articlesService: ArticlesService) {}

  @Post()
  @UseGuards(AuthGuard('jwt'))
  create(@Body() createArticleDto: Prisma.ArticleCreateInput) {
    return this.articlesService.create(createArticleDto);
  }

  @Get()
  findAll(@Query() filters: FilterArticleDto) {
    return this.articlesService.findAll(filters);
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.articlesService.findOne(+id);
  }

  @Patch(':id')
  @UseGuards(AuthGuard('jwt'))
  update(@Param('id') id: string, @Body() updateArticleDto: Prisma.ArticleUpdateInput) {
    return this.articlesService.update(+id, updateArticleDto);
  }

  @Delete(':id')
  @UseGuards(AuthGuard('jwt'))
  remove(@Param('id') id: string) {
    return this.articlesService.remove(+id);
  }
}
</file>

<file path="articles/articles.module.ts">
import { Module } from '@nestjs/common';
import { ArticlesController } from './articles.controller';
import { ArticlesService } from './articles.service';
import { FilteringService } from './filtering.service';

@Module({

  controllers: [ArticlesController],
  providers: [ArticlesService, FilteringService]
 
})
export class ArticlesModule {}
</file>

<file path="articles/articles.service.ts">
import { Injectable } from '@nestjs/common';
import { DatabaseService } from '../../database/database.service';
import { Prisma } from '@prisma/client';
import { FilteringService } from './filtering.service';
import { FilterArticleDto } from './dto/filter-article.dto';

@Injectable()
export class ArticlesService {
  constructor(private prisma: DatabaseService, private filteringService:FilteringService) {}
  
  private filterConfig = {
    category: { field: 'category', operator: 'equals' },  
  }

  async create(createArticleDto: Prisma.ArticleCreateInput) {
    return this.prisma.article.create({
      data: {
        ...createArticleDto,
        content: createArticleDto.content
      },
      include: { content: true }
    });
  }

  async findAll(filters: FilterArticleDto) {
    const where = this.filteringService.createWhereCondition(filters, this.filterConfig);


    return this.prisma.article.findMany({
      where,
      include: { content: true },
      orderBy: { createdAt: 'desc' }
    });
  }

  async findOne(id: number) {
    return this.prisma.article.findUnique({
      where: { id },
      include: { content: true }
    });
  }

  async update(id: number, updateArticleDto: Prisma.ArticleUpdateInput) {
    // First, delete all existing content items for this article
    await this.prisma.contentItem.deleteMany({
      where: { articleId: id }
    });

    // Then update the article with new content items
    return this.prisma.article.update({
      where: { id },
      data: {
        title: updateArticleDto.title as string,
        category: updateArticleDto.category as string,
        content: updateArticleDto.content
      },
      include: { content: true }
    });
  }

  async remove(id: number) {
    return this.prisma.article.delete({
      where: { id }
    });
  }
}
</file>

<file path="articles/filtering.service.ts">
import { Injectable } from '@nestjs/common';
import { Prisma } from '@prisma/client';

@Injectable()
export class FilteringService {
  /**
   * Creates a Prisma where condition based on filter parameters
   * @param filters Object containing filter parameters
   * @param config Configuration for mapping filter fields to database fields
   * @returns Prisma where condition
   */
  createWhereCondition(
    filters: Record<string, any>,
    config: Record<string, { field: string; operator: string; type?: string }>,
  ): Prisma.ArticleWhereInput {
    const whereCondition: Prisma.ArticleWhereInput = {};
    
    // Remove pagination and sorting parameters
    const { page, limit, sortBy, sortOrder, ...actualFilters } = filters;

    // Process each filter
    Object.keys(actualFilters).forEach((key) => {
      if (actualFilters[key] !== undefined && config[key]) {
        const { field, operator, type } = config[key];
        let value = actualFilters[key];
        
        // Convert value based on type if specified
        if (type === 'number' || type === 'int') {
          // Handle array values for 'in' operator
          if (operator === 'in' && Array.isArray(value)) {
            value = value.map(item => Number(item));
          } else {
            value = Number(value);
          }
        }
        
        switch (operator) {
          case 'equals':
            whereCondition[field] = { equals: value };
            break;
          case 'contains':
            whereCondition[field] = { contains: value };
            break;
          case 'in':
            whereCondition[field] = { in: value };
            break;
          // Add more operators as needed
          default:
            whereCondition[field] = { equals: value };
        }
      }
    });

    return whereCondition;
  }

  /**
   * Creates pagination parameters for Prisma
   * @param filters Object containing pagination parameters
   * @returns Pagination object with skip and take properties
   */
  createPaginationParams(filters: { page?: number; limit?: number }) {
    const page = filters.page || 1;
    const limit = filters.limit || 10;
    
    return {
      skip: (page - 1) * limit,
      take: limit,
    };
  }

  /**
   * Creates sorting parameters for Prisma
   * @param filters Object containing sorting parameters
   * @param config Configuration for mapping filter fields to database fields
   * @returns Sorting object for Prisma orderBy
   */
  createSortingParams(
    filters: { sortBy?: string; sortOrder?: 'asc' | 'desc' },
    config: Record<string, { field: string; operator: string; type?: string }>,
  ) {
    if (!filters.sortBy) {
      return undefined;
    }

    // Find the database field name from config
    const configEntry = Object.entries(config).find(
      ([key, value]) => key === filters.sortBy || value.field === filters.sortBy
    );

    // If field is found in config, use the mapped field name, otherwise use the provided sortBy
    const fieldName = configEntry ? configEntry[1].field : filters.sortBy;
    const direction = filters.sortOrder || 'asc';

    return {
      [fieldName]: direction,
    };
  }
}
</file>

<file path="structure/structure.controller.ts">
import { Controller, Get, Post, Body, Patch, Param, Delete, UseGuards } from '@nestjs/common';
import { StructureService } from './structure.service';
import { Prisma } from '@prisma/client';
import { AuthGuard } from '@nestjs/passport';

@Controller('structure')
export class StructureController {
  constructor(private readonly structureService: StructureService) {}

  @Post()
  @UseGuards(AuthGuard('jwt'))
  create(@Body() createStructureDto: Prisma.StructureCreateInput) {
    return this.structureService.create(createStructureDto);
  }

  @Get()
  findAll() {
    return this.structureService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.structureService.findOne(+id);
  }

  @Patch(':id')
  @UseGuards(AuthGuard('jwt'))
  update(@Param('id') id: string, @Body() updateStructureDto: Prisma.StructureUpdateInput) {
    return this.structureService.update(+id, updateStructureDto);
  }

  @Delete(':id')
  @UseGuards(AuthGuard('jwt'))
  remove(@Param('id') id: string) {
    return this.structureService.remove(+id);
  }
}
</file>

<file path="structure/structure.module.ts">
import { Module } from '@nestjs/common';
import { StructureService } from './structure.service';
import { StructureController } from './structure.controller';

@Module({
  controllers: [StructureController],
  providers: [StructureService],
})
export class StructureModule {}
</file>

<file path="structure/structure.service.ts">
import { Injectable } from '@nestjs/common';
import { DatabaseService } from '../../database/database.service';
import { Prisma } from '@prisma/client';
import { getRomanianDate } from 'src/utils/timezone';

@Injectable()
export class StructureService {
  constructor(private readonly databaseService: DatabaseService) {}

  async create(createStructureDto: Prisma.StructureCreateInput) {
    return this.databaseService.structure.create({
      data: createStructureDto,
    });
  }

  findAll() {
    return this.databaseService.structure.findMany({});
  }

  findOne(id: number) {
    return this.databaseService.structure.findUnique({
      where: { id },
    });
  }

  async update(id: number, updateStructureDto: Prisma.StructureUpdateInput) {
    console.log('update ',getRomanianDate())
    return this.databaseService.structure.update({
      where: { id },
      data: 
        updateStructureDto
   
      
    });
  }

  remove(id: number) {
    return this.databaseService.structure.delete({
      where: { id },
    });
  }
}
</file>

<file path="structure-attributes/dto/filter-structure-attribute.dto.ts">
import { IsOptional, IsString, IsNumber, IsBoolean, IsIn } from 'class-validator';
import { Transform, Type } from 'class-transformer';

export class FilterStructureAttributeDto {
  @IsOptional()
  @IsString()
  attributeName?: string;

  @IsOptional()
  @IsString()
  exactAttributeName?: string;

  @IsOptional()
  @IsString()
  attributeValue?: string;

  @IsOptional()
  @IsNumber()
  @Type(() => Number)
  structureId?: number;

  @IsOptional()
  @IsBoolean()
  @Transform(({ value }) => {
    if (value === 'true') return true;
    if (value === 'false') return false;
    return value;
  })
  isActive?: boolean;
  
  @IsOptional()
  @IsString()
  stare?: string;
  // Add more filters as needed based on your structure-attributes model

  // Pagination parameters
  @IsOptional()
  @IsNumber()
  @Type(() => Number)
  page?: number;

  @IsOptional()
  @IsNumber()
  @Type(() => Number)
  limit?: number;

  // Sorting parameters
  @IsOptional()
  @IsString()
  sortBy?: string;

  @IsOptional()
  @IsString()
  @IsIn(['asc', 'desc', 'ASC', 'DESC'])
  @Transform(({ value }) => value?.toLowerCase())
  sortOrder?: 'asc' | 'desc';
}
</file>

<file path="structure-attributes/filter.service.ts">
import { Injectable } from '@nestjs/common';
import { Prisma } from '@prisma/client';

@Injectable()
export class FilterService {
  /**
   * Creates a Prisma where condition based on filter parameters
   * @param filters Object containing filter parameters
   * @param config Configuration for mapping filter fields to database fields
   * @returns Prisma where condition
   */
  createWhereCondition(
    filters: Record<string, any>,
    config: Record<string, { field: string; operator: string; type?: string }>,
  ): Prisma.StructureAttributesWhereInput {
    const whereCondition: Prisma.StructureAttributesWhereInput = {};
    
    // Remove pagination and sorting parameters
    const { page, limit, sortBy, sortOrder, ...actualFilters } = filters;

    // Process each filter
    Object.keys(actualFilters).forEach((key) => {
      if (actualFilters[key] !== undefined && config[key]) {
        const { field, operator, type } = config[key];
        let value = actualFilters[key];
        
        // Convert value based on type if specified
        if (type === 'number' || type === 'int') {
          // Handle array values for 'in' operator
          if (operator === 'in' && Array.isArray(value)) {
            value = value.map(item => Number(item));
          } else {
            value = Number(value);
          }
        }
        
        switch (operator) {
          case 'equals':
            whereCondition[field] = { equals: value };
            break;
          case 'contains':
            whereCondition[field] = { contains: value };
            break;
          case 'in':
            whereCondition[field] = { in: value };
            break;
          // Add more operators as needed
          default:
            whereCondition[field] = { equals: value };
        }
      }
    });

    return whereCondition;
  }

  /**
   * Creates pagination parameters for Prisma
   * @param filters Object containing pagination parameters
   * @returns Pagination object with skip and take properties
   */
  createPaginationParams(filters: { page?: number; limit?: number }) {
    const page = filters.page || 1;
    const limit = filters.limit || 10;
    
    return {
      skip: (page - 1) * limit,
      take: limit,
    };
  }

  /**
   * Creates sorting parameters for Prisma
   * @param filters Object containing sorting parameters
   * @param config Configuration for mapping filter fields to database fields
   * @returns Sorting object for Prisma orderBy
   */
  createSortingParams(
    filters: { sortBy?: string; sortOrder?: 'asc' | 'desc' },
    config: Record<string, { field: string; operator: string; type?: string }>,
  ) {
    if (!filters.sortBy) {
      return undefined;
    }

    // Find the database field name from config
    const configEntry = Object.entries(config).find(
      ([key, value]) => key === filters.sortBy || value.field === filters.sortBy
    );

    // If field is found in config, use the mapped field name, otherwise use the provided sortBy
    const fieldName = configEntry ? configEntry[1].field : filters.sortBy;
    const direction = filters.sortOrder || 'asc';

    return {
      [fieldName]: direction,
    };
  }
}
</file>

<file path="structure-attributes/structure-attributes.controller.ts">
import { Controller, Get, Post, Body, Patch, Param, Delete, UseGuards, Query } from '@nestjs/common';
import { StructureAttributesService } from './structure-attributes.service';
import { Prisma } from '@prisma/client';
import { AuthGuard } from '@nestjs/passport';
import { FilterStructureAttributeDto } from './dto/filter-structure-attribute.dto';
@Controller('structure-attributes')
export class StructureAttributesController {
  constructor(private readonly structureAttributesService: StructureAttributesService) {}

  @Post()
  @UseGuards(AuthGuard('jwt'))
  create(@Body() createStructureAttributeDto: Prisma.StructureAttributesCreateInput) {
    return this.structureAttributesService.create(createStructureAttributeDto);
  }

  @Get()
  findAll(@Query() filters: FilterStructureAttributeDto) {
    return this.structureAttributesService.findAll(filters);
  }

  @Get('structure')
  findAllStructures() {
    return this.structureAttributesService.findAllStructures();  
  }
  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.structureAttributesService.findOne(+id);
  }

  @Patch(':id')
  @UseGuards(AuthGuard('jwt'))
  update(
    @Param('id') id: string,
    @Body() updateStructureAttributeDto: Prisma.StructureAttributesUpdateInput,
  ) {
    return this.structureAttributesService.update(+id, updateStructureAttributeDto);
  }

  @Delete(':id')
  @UseGuards(AuthGuard('jwt'))
  remove(@Param('id') id: string) {
    return this.structureAttributesService.remove(+id);
  }
}
</file>

<file path="structure-attributes/structure-attributes.module.ts">
import { Module } from '@nestjs/common';
import { StructureAttributesService } from './structure-attributes.service';
import { StructureAttributesController } from './structure-attributes.controller';
import { FilterService } from './filter.service';

@Module({
  controllers: [StructureAttributesController],
  providers: [StructureAttributesService, FilterService],
})
export class StructureAttributesModule {}
</file>

<file path="structure-attributes/structure-attributes.service.ts">
import { Injectable } from '@nestjs/common';
import { DatabaseService } from '../../database/database.service';
import { Prisma } from '@prisma/client';
import { FilterService } from './filter.service';
import { FilterStructureAttributeDto } from './dto/filter-structure-attribute.dto';
@Injectable()
export class StructureAttributesService {
  private filterConfig = {
    attributeName: { field: 'attributeName', operator: 'contains' },
    exactAttributeName: { field: 'attributeName', operator: 'equals' },
    attributeValue: { field: 'attributeValue', operator: 'contains' },
    structureId: { field: 'structureId', operator: 'equals' , type:'int'},
    stare: { field: 'status', operator: 'equals' },
    // Add more mappings as needed
  };
  constructor(private readonly databaseService: DatabaseService, private filterService:FilterService) {}

  async create(data: Prisma.StructureAttributesCreateInput) {
    return this.databaseService.structureAttributes.create({
      data,
    });
  }

  async findAll(filters: FilterStructureAttributeDto) {
    const where = this.filterService.createWhereCondition(filters, this.filterConfig);
    const pagination = this.filterService.createPaginationParams(filters);
    const orderBy = this.filterService.createSortingParams(filters, this.filterConfig);

    const [data, total] = await Promise.all([
      this.databaseService.structureAttributes.findMany({
        where,
        include: {
          structure: true,
        },
        orderBy,
        ...pagination,
      }),
      this.databaseService.structureAttributes.count({ where }),
    ]);

    return {
      data,
      meta: {
        total,
        page: filters.page || 1,
        limit: filters.limit || 10,
        totalPages: Math.ceil(total / (filters.limit || 10)),
      },
    };
  }
 async findAllStructures(){
  return this.databaseService.structure.findMany({});
 }
  async findOne(id: number) {
    return this.databaseService.structureAttributes.findUnique({
      where: { id },
      include: {
        structure: true,
      },
    });
  }

  async update(id: number, data: Prisma.StructureAttributesUpdateInput) {
    return this.databaseService.structureAttributes.update({
      where: { id },
      data,
    });
  }

  async remove(id: number) {
    return this.databaseService.structureAttributes.delete({
      where: { id },
    });
  }
}
</file>

</files>
