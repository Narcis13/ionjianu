This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
assets/
  quasar-logo-vertical.svg
boot/
  axios.js
components/
  BlogView.vue
  DrawerTabs.vue
  DynamicCrud.vue
  EssentialLink.vue
  Meniu.vue
  ModelCrudTable.vue
config/
  api.js
css/
  app.scss
  quasar.variables.scss
layouts/
  MainLayout.vue
pages/
  ArticleEditPage.vue
  ArticleListPage.vue
  ArticleViewPage.vue
  AtributeStructuri.vue
  ErrorNotFound.vue
  IndexPage.vue
  Structuri.vue
  Utilizatori.vue
router/
  index.js
  routes.js
services/
  ArticleService.ts
stores/
  index.js
  useUtilizatorStores.js
types/
  models.ts
App.vue
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="assets/quasar-logo-vertical.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 356 360">
	<path
		d="M43.4 303.4c0 3.8-2.3 6.3-7.1 6.3h-15v-22h14.4c4.3 0 6.2 2.2 6.2 5.2 0 2.6-1.5 4.4-3.4 5 2.8.4 4.9 2.5 4.9 5.5zm-8-13H24.1v6.9H35c2.1 0 4-1.3 4-3.8 0-2.2-1.3-3.1-3.7-3.1zm5.1 12.6c0-2.3-1.8-3.7-4-3.7H24.2v7.7h11.7c3.4 0 4.6-1.8 4.6-4zm36.3 4v2.7H56v-22h20.6v2.7H58.9v6.8h14.6v2.3H58.9v7.5h17.9zm23-5.8v8.5H97v-8.5l-11-13.4h3.4l8.9 11 8.8-11h3.4l-10.8 13.4zm19.1-1.8V298c0-7.9 5.2-10.7 12.7-10.7 7.5 0 13 2.8 13 10.7v1.4c0 7.9-5.5 10.8-13 10.8s-12.7-3-12.7-10.8zm22.7 0V298c0-5.7-3.9-8-10-8-6 0-9.8 2.3-9.8 8v1.4c0 5.8 3.8 8.1 9.8 8.1 6 0 10-2.3 10-8.1zm37.2-11.6v21.9h-2.9l-15.8-17.9v17.9h-2.8v-22h3l15.6 18v-18h2.9zm37.9 10.2v1.3c0 7.8-5.2 10.4-12.4 10.4H193v-22h11.2c7.2 0 12.4 2.8 12.4 10.3zm-3 0c0-5.3-3.3-7.6-9.4-7.6h-8.4V307h8.4c6 0 9.5-2 9.5-7.7V298zm50.8-7.6h-9.7v19.3h-3v-19.3h-9.7v-2.6h22.4v2.6zm34.4-2.6v21.9h-3v-10.1h-16.8v10h-2.8v-21.8h2.8v9.2H296v-9.2h2.9zm34.9 19.2v2.7h-20.7v-22h20.6v2.7H316v6.8h14.5v2.3H316v7.5h17.8zM24 340.2v7.3h13.9v2.4h-14v9.6H21v-22h20v2.7H24zm41.5 11.4h-9.8v7.9H53v-22h13.3c5.1 0 8 1.9 8 6.8 0 3.7-2 6.3-5.6 7l6 8.2h-3.3l-5.8-8zm-9.8-2.6H66c3.1 0 5.3-1.5 5.3-4.7 0-3.3-2.2-4.1-5.3-4.1H55.7v8.8zm47.9 6.2H89l-2 4.3h-3.2l10.7-22.2H98l10.7 22.2h-3.2l-2-4.3zm-1-2.3l-6.3-13-6 13h12.2zm46.3-15.3v21.9H146v-17.2L135.7 358h-2.1l-10.2-15.6v17h-2.8v-21.8h3l11 16.9 11.3-17h3zm35 19.3v2.6h-20.7v-22h20.6v2.7H166v6.8h14.5v2.3H166v7.6h17.8zm47-19.3l-8.3 22h-3l-7.1-18.6-7 18.6h-3l-8.2-22h3.3L204 356l6.8-18.5h3.4L221 356l6.6-18.5h3.3zm10 11.6v-1.4c0-7.8 5.2-10.7 12.7-10.7 7.6 0 13 2.9 13 10.7v1.4c0 7.9-5.4 10.8-13 10.8-7.5 0-12.7-3-12.7-10.8zm22.8 0v-1.4c0-5.7-4-8-10-8s-9.9 2.3-9.9 8v1.4c0 5.8 3.8 8.2 9.8 8.2 6.1 0 10-2.4 10-8.2zm28.3 2.4h-9.8v7.9h-2.8v-22h13.2c5.2 0 8 1.9 8 6.8 0 3.7-2 6.3-5.6 7l6 8.2h-3.3l-5.8-8zm-9.8-2.6h10.2c3 0 5.2-1.5 5.2-4.7 0-3.3-2.1-4.1-5.2-4.1h-10.2v8.8zm40.3-1.5l-6.8 5.6v6.4h-2.9v-22h2.9v12.3l15.2-12.2h3.7l-9.9 8.1 10.3 13.8h-3.6l-8.9-12z" />
	<path fill="#050A14"
		d="M188.4 71.7a10.4 10.4 0 01-20.8 0 10.4 10.4 0 1120.8 0zM224.2 45c-2.2-3.9-5-7.5-8.2-10.7l-12 7c-3.7-3.2-8-5.7-12.6-7.3a49.4 49.4 0 00-9.7 13.9 59 59 0 0140.1 14l7.6-4.4a57 57 0 00-5.2-12.5zM178 125.1c4.5 0 9-.6 13.4-1.7v-14a40 40 0 0012.5-7.2 47.7 47.7 0 00-7.1-15.3 59 59 0 01-32.2 27.7v8.7c4.4 1.2 8.9 1.8 13.4 1.8zM131.8 45c-2.3 4-4 8.1-5.2 12.5l12 7a40 40 0 000 14.4c5.7 1.5 11.3 2 16.9 1.5a59 59 0 01-8-41.7l-7.5-4.3c-3.2 3.2-6 6.7-8.2 10.6z" />
	<path fill="#00B4FF"
		d="M224.2 98.4c2.3-3.9 4-8 5.2-12.4l-12-7a40 40 0 000-14.5c-5.7-1.5-11.3-2-16.9-1.5a59 59 0 018 41.7l7.5 4.4c3.2-3.2 6-6.8 8.2-10.7zm-92.4 0c2.2 4 5 7.5 8.2 10.7l12-7a40 40 0 0012.6 7.3c4-4.1 7.3-8.8 9.7-13.8a59 59 0 01-40-14l-7.7 4.4c1.2 4.3 3 8.5 5.2 12.4zm46.2-80c-4.5 0-9 .5-13.4 1.7V34a40 40 0 00-12.5 7.2c1.5 5.7 4 10.8 7.1 15.4a59 59 0 0132.2-27.7V20a53.3 53.3 0 00-13.4-1.8z" />
	<path fill="#00B4FF"
		d="M178 9.2a62.6 62.6 0 11-.1 125.2A62.6 62.6 0 01178 9.2m0-9.2a71.7 71.7 0 100 143.5A71.7 71.7 0 00178 0z" />
	<path fill="#050A14"
		d="M96.6 212v4.3c-9.2-.8-15.4-5.8-15.4-17.8V180h4.6v18.4c0 8.6 4 12.6 10.8 13.5zm16-31.9v18.4c0 8.9-4.3 12.8-10.9 13.5v4.4c9.2-.7 15.5-5.6 15.5-18v-18.3h-4.7zM62.2 199v-2.2c0-12.7-8.8-17.4-21-17.4-12.1 0-20.7 4.7-20.7 17.4v2.2c0 12.8 8.6 17.6 20.7 17.6 1.5 0 3-.1 4.4-.3l11.8 6.2 2-3.3-8.2-4-6.4-3.1a32 32 0 01-3.6.2c-9.8 0-16-3.9-16-13.3v-2.2c0-9.3 6.2-13.1 16-13.1 9.9 0 16.3 3.8 16.3 13.1v2.2c0 5.3-2.1 8.7-5.6 10.8l4.8 2.4c3.4-2.8 5.5-7 5.5-13.2zM168 215.6h5.1L156 179.7h-4.8l17 36zM143 205l7.4-15.7-2.4-5-15.1 31.4h5.1l3.3-7h18.3l-1.8-3.7H143zm133.7 10.7h5.2l-17.3-35.9h-4.8l17 36zm-25-10.7l7.4-15.7-2.4-5-15.1 31.4h5.1l3.3-7h18.3l-1.7-3.7h-14.8zm73.8-2.5c6-1.2 9-5.4 9-11.4 0-8-4.5-10.9-12.9-10.9h-21.4v35.5h4.6v-31.3h16.5c5 0 8.5 1.4 8.5 6.7 0 5.2-3.5 7.7-8.5 7.7h-11.4v4.1h10.7l9.3 12.8h5.5l-9.9-13.2zm-117.4 9.9c-9.7 0-14.7-2.5-18.6-6.3l-2.2 3.8c5.1 5 11 6.7 21 6.7 1.6 0 3.1-.1 4.6-.3l-1.9-4h-3zm18.4-7c0-6.4-4.7-8.6-13.8-9.4l-10.1-1c-6.7-.7-9.3-2.2-9.3-5.6 0-2.5 1.4-4 4.6-5l-1.8-3.8c-4.7 1.4-7.5 4.2-7.5 8.9 0 5.2 3.4 8.7 13 9.6l11.3 1.2c6.4.6 8.9 2 8.9 5.4 0 2.7-2.1 4.7-6 5.8l1.8 3.9c5.3-1.6 8.9-4.7 8.9-10zm-20.3-21.9c7.9 0 13.3 1.8 18.1 5.7l1.8-3.9a30 30 0 00-19.6-5.9c-2 0-4 .1-5.7.3l1.9 4 3.5-.2z" />
	<path fill="#00B4FF"
		d="M.5 251.9c29.6-.5 59.2-.8 88.8-1l88.7-.3 88.7.3 44.4.4 44.4.6-44.4.6-44.4.4-88.7.3-88.7-.3a7981 7981 0 01-88.8-1z" />
	<path fill="none" d="M-565.2 324H-252v15.8h-313.2z" />
</svg>
</file>

<file path="boot/axios.js">
import { defineBoot } from '#q-app/wrappers'
import axios from 'axios'

// Be careful when using SSR for cross-request state pollution
// due to creating a Singleton instance here;
// If any client changes this (global) instance, it might be a
// good idea to move this instance creation inside of the
// "export default () => {}" function below (which runs individually
// for each client)
const api = axios.create({ baseURL: 'https://api.example.com' })

export default defineBoot(({ app }) => {
  // for use inside Vue files (Options API) through this.$axios and this.$api

  app.config.globalProperties.$axios = axios
  // ^ ^ ^ this will allow you to use this.$axios (for Vue Options API form)
  //       so you won't necessarily have to import axios in each vue file

  app.config.globalProperties.$api = api
  // ^ ^ ^ this will allow you to use this.$api (for Vue Options API form)
  //       so you can easily perform requests against your app's API
})

export { api }
</file>

<file path="components/BlogView.vue">
<template>
  <div class="blog-container">
    <!-- Loading state -->
    <div v-if="isLoading" class="loading">
      <div class="spinner"></div>
      <p>Loading articles...</p>
    </div>
    
    <!-- Error state -->
    <div v-else-if="error" class="error-message">
      <p>{{ error }}</p>
    </div>

    <!-- Conditional Rendering: Show List or Selected Article -->
    <div v-else>
      <!-- Articles list View (shown if no article is selected) -->
      <div v-if="!selectedArticle">
        <div v-if="articles.length > 0" class="articles-list">
          <div v-for="article in articles" :key="article.id" class="article-card">
            <div class="article-title">{{ article.title }}</div>
            <div class="article-date-under-title">{{ new Date(article.updatedAt).toLocaleDateString() }}</div>
            <div class="article-meta">
              <span class="article-category">{{ article.category }}</span>
            </div>
            <button
              class="read-button"
              @click="selectArticle(article)"
            >
              READ
            </button>
          </div>
        </div>
        <!-- No articles state -->
        <div v-else class="no-articles">
          <p>No articles found.</p>
        </div>
      </div>

      <!-- Selected Article View (shown if an article is selected) -->
      <div v-else>
        <div class="article-header">
          <button class="back-button" @click="selectedArticle = null">‚Üê Back to list</button>
          <h1 class="article-title">{{ selectedArticle.title }}</h1>
          <div class="article-meta">
            <span class="article-category">Category: {{ selectedArticle.category }}</span>
            <!-- Consider adding date here too if needed -->
          </div>
        </div>
        <div class="article-content">
          <div
            v-for="(item, index) in selectedArticle.content"
            :key="index"
            class="content-item"
          >
            <!-- Paragraph content -->
            <div v-if="item.type === 'PARAGRAPH'" class="paragraph" v-html="item.html"></div>

            <!-- File content -->
            <div v-else-if="item.type === 'FILE'" class="file">
              <span class="file-icon">üìé</span>
              <a :href="item.url" target="_blank" rel="noopener noreferrer">{{ item.name }}</a>
            </div>

            <!-- Image content -->
            <div v-else-if="item.type === 'IMAGE'" class="image">
              <img :src="item.src" :alt="item.alt">
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, watch } from 'vue';
import { Article } from '../types/models';

const props = defineProps<{
  apiUrl: string
}>();

const articles = ref<Article[]>([]);
const selectedArticle = ref<Article | null>(null);
const isLoading = ref(false);
const error = ref<string | null>(null);

// Fetch articles from the provided API URL
const fetchArticles = async () => {
  isLoading.value = true;
  error.value = null;
  
  try {
    const response = await fetch(props.apiUrl);
    
    if (!response.ok) {
      throw new Error(`Failed to fetch articles: ${response.status} ${response.statusText}`);
    }
    
    articles.value = await response.json();
  } catch (err) {
    console.error('Error fetching articles:', err);
    error.value = err instanceof Error ? err.message : 'Failed to load articles';
  } finally {
    isLoading.value = false;
  }
};

// Select an article to view
const selectArticle = (article: Article) => {
  selectedArticle.value = article;
};

// Watch for changes to the API URL and refetch when it changes
watch(() => props.apiUrl, () => {
  fetchArticles();
});

// Fetch articles when the component is mounted
onMounted(() => {
  fetchArticles();
});
</script>

<style scoped>
/* Container styles */
.blog-container {
  font-family: Arial, sans-serif;
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
  color: #333;
}

/* Loading state */
.loading {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 40px 0;
}

.spinner {
  border: 4px solid rgba(0, 0, 0, 0.1);
  border-radius: 50%;
  border-top: 4px solid #3498db;
  width: 40px;
  height: 40px;
  animation: spin 1s linear infinite;
  margin-bottom: 10px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Error message */
.error-message {
  background-color: #ffebee;
  color: #c62828;
  padding: 15px;
  border-radius: 4px;
  margin: 20px 0;
}

/* Articles list */
.articles-list {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 20px;
}

.article-card {
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  padding: 20px;
  transition: box-shadow 0.3s ease;
  display: flex;
  flex-direction: column;
}

.article-card:hover {
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

.article-title {
  margin-top: 0;
  margin-bottom: 3px;
  font-size: 1.25rem;
  color: #333;
}

.article-meta {
  margin-bottom: 15px;
  font-size: 0.9rem;
  color: #666;
  display: flex; /* Align category and potential future meta items */
  justify-content: space-between; /* Example alignment */
  align-items: center;
}

.article-date-under-title {
  font-size: 0.85rem;
  color: #888;
  margin-bottom: 10px; /* Space below the date */
}

.article-category {
  background-color: #f5f5f5;
  padding: 3px 8px;
  border-radius: 12px;
  display: inline-block;
}

.read-button {
  background-color: #3498db;
  color: white;
  border: none;
  padding: 8px 16px;
  border-radius: 4px;
  cursor: pointer;
  font-weight: bold;
  margin-top: auto;
  transition: background-color 0.2s ease;
}

.read-button:hover {
  background-color: #2980b9;
}

/* No articles state */
.no-articles {
  background-color: #f5f5f5;
  padding: 30px;
  text-align: center;
  border-radius: 4px;
  margin: 20px 0;
}

/* Selected Article View Styles */
.article-header {
  margin-bottom: 30px;
  border-bottom: 1px solid #eee; /* Optional separator */
  padding-bottom: 20px; /* Optional spacing */
}

.back-button {
  background: none;
  border: none;
  color: #3498db;
  cursor: pointer;
  font-size: 1rem;
  padding: 0;
  margin-bottom: 20px;
  display: inline-block;
}

.back-button:hover {
  text-decoration: underline;
}

.article-content {
  line-height: 1.6;
}

.content-item {
  margin-bottom: 20px;
}

.paragraph {
  margin-bottom: 15px;
}

.file {
  display: flex;
  align-items: center;
  background-color: #f5f5f5;
  padding: 10px;
  border-radius: 4px;
}

.file-icon {
  margin-right: 10px;
}

.file a {
  color: #3498db;
  text-decoration: none;
}

.file a:hover {
  text-decoration: underline;
}

.image img {
  max-width: 100%;
  height: auto;
  border-radius: 4px;
}
</style>
</file>

<file path="components/DrawerTabs.vue">
<template>
    <div class="drawer-tabs q-pb-md">
   <!-- <q-tabs
        v-model="activeTab"
        dense
        class="text-grey"
        active-color="primary"
        indicator-color="primary"
        align="justify"
        narrow-indicator
      >
        <q-tab name="tab1" label="Login" />
        <q-tab name="tab2" label="Profil" />
      </q-tabs> 
  
      <q-separator /> -->
  
      <q-tab-panels v-model="activeTab" animated>
        <q-tab-panel name="tab1">
          <!-- Login Form -->
          <div class="login-form q-pa-md flex flex-center">
            <q-form @submit="onSubmit" class="q-gutter-y-md" style="width: 100%;">
              <q-input
                v-model="username"
                label="Username"
                outlined
                dense
                :rules="[val => !!val || 'Username este obligatoriu']"
              />
              
              <q-input
                v-model="password"
                label="Password"
                outlined
                dense
                type="password"
                :rules="[val => !!val || 'Password este obligatoriu']"
              />
              
              <div class="q-mt-md flex flex-center">
                <q-btn 
                  label="Autentificare" 
                  type="submit" 
                  color="primary"
                  class="q-mt-sm" 
                />
              </div>
            </q-form>
          </div>
        </q-tab-panel>
  
        <q-tab-panel name="tab2">
          <!-- User Info Card -->
          <q-card flat bordered class="q-pa-md">
            <q-card-section>
              <div class="text-h6 q-mb-xs">Informatii Utilizator </div>
              <q-separator />
            </q-card-section>
            
            <q-card-section>
              <div class="q-py-sm">
                <div class="text-subtitle2">Utilizator</div>
                <div>{{utilizatorStore.utilizator.user_profile.username+' '+ utilizatorStore.utilizator.user_profile.email|| 'Neautentificat' }}</div>
              </div>
              
              <div class="q-py-sm">
                <div class="text-subtitle2">Rol</div>
                <div>{{ userInfo.role || 'Administrator' }}</div>
              </div>
              
              <div class="q-py-sm">
                <div class="text-subtitle2">Ultima conectare</div>
                <div>{{ userInfo.lastLogin || '2025-02-26 15:30' }}</div>
              </div>
            </q-card-section>
            
            <q-card-actions align="center">
              <q-btn 
                label="Inchide sesiunea" 
                color="negative" 
                @click="logout" 
              />
            </q-card-actions>
          </q-card>
        </q-tab-panel>
      </q-tab-panels>
    </div>
  </template>
  
  <script setup>
  import { ref } from 'vue';
  import { useQuasar } from 'quasar'
  import { useRouter } from 'vue-router'
  import { useUtilizatorStore } from 'stores/useUtilizatorStores';
  import { host } from '../config/api';
  import axios from 'axios';
  
  const activeTab = ref('tab1');
  const username = ref('');
  const password = ref('');
  const utilizatorStore = useUtilizatorStore();
  const $q = useQuasar();
  const loading = ref(false);
  const router = useRouter()
  // User information state
  const userInfo = ref({
    name: '',
    role: '',
    lastLogin: '',
    first_name: '',
    last_name: '',
    avatar: null
  });
  
  async function onSubmit() {
    try {
      loading.value = true;
      const response = await axios.post(`${host}/auth/login`, {
        username: username.value,
        password: password.value
      });
     // console.log(response);
      // Update user info with response data
      /*userInfo.value = {
        name: `${response.data.first_name} ${response.data.last_name}`,
        role: response.data.role,
        lastLogin: new Date().toLocaleString(),
        avatar: response.data.avatar
      };*/
  
      // Store user data in the utilizator store
      utilizatorStore.autentificare(response.data);
      console.log(utilizatorStore.utilizator.access_token)
      // Show success notification
      $q.notify({
        type: 'positive',
        message: 'Autentificare reu»ôitƒÉ!',
        position: 'top'
      });
  
      // Switch to profile tab
      activeTab.value = 'tab2';
  
      // Clear form
      username.value = '';
      password.value = '';
    } catch (error) {
      // Handle different error scenarios
      const errorMessage = error.response?.data?.message || 'Eroare la autentificare';
      $q.notify({
        type: 'negative',
        message: errorMessage,
        position: 'top'
      });
    } finally {
      loading.value = false;
    }
  }
  
  function logout() {
    // Clear user info
    userInfo.value = {
      name: '',
      role: '',
      lastLogin: '',
      first_name: '',
      last_name: '',
      avatar: null
    };
  
    // Clear store
    utilizatorStore.logout();
  
    // Show notification
    $q.notify({
      type: 'info',
      message: 'V-a»õi deconectat cu succes',
      position: 'top'
    });
  
    // Switch to login tab
    activeTab.value = 'tab1';
// Redirect to root page using router
   router.push('/');
  }
  </script>
  
  <style scoped>
  .drawer-tabs {
    width: 100%;
  }
  
  .login-form {
    max-width: 300px;
    margin: 0 auto;
  }
  </style>
</file>

<file path="components/DynamicCrud.vue">
<template>
    <div class="q-pa-md">
      <h4>{{ modelName }} Management</h4>
      
      <!-- Data Table -->
      <q-table
        :rows="items"
        :columns="columns"
        row-key="id"
        :loading="loading"
        :filter="filter"
        :pagination="pagination"
       
      >
        <template v-slot:top>
          <div class="row full-width">
            <div class="col-6">
              <q-input dense debounce="300" v-model="filter" placeholder="Search">
                <template v-slot:append>
                  <q-icon name="search" />
                </template>
              </q-input>
            </div>
            <div class="col-6 flex justify-end">
              <q-btn color="primary" icon="add" label="Add" @click="openDialog()" />
            </div>
          </div>
        </template>
        
        <template v-slot:body-cell-actions="props">
          <q-td :props="props">
            <div class="q-gutter-sm">
              <q-btn size="sm" color="info" icon="edit" dense flat @click="openDialog(props.row)" />
              <q-btn size="sm" color="negative" icon="delete" dense flat @click="confirmDelete(props.row)" />
            </div>
          </q-td>
        </template>
      </q-table>
      
      <!-- Form Dialog -->
      <q-dialog v-model="showDialog" persistent>
        <q-card class="q-pa-md" style="min-width: 500px">
          <q-card-section>
            <div class="text-h6">{{ editingItem.id ? 'Edit' : 'Add' }} {{ modelName }}</div>
          </q-card-section>
  
          <q-card-section>
            <q-form @submit="saveItem" ref="itemForm">
              <div class="row q-col-gutter-md">
                <template v-for="field in formFields" :key="field.name">
                  <!-- Special handling for relation fields -->
                  <div v-if="field.isRelation" class="col-12">
                    <q-select
                      v-model="editingItem[field.name + 'Id']"
                      :label="formatLabel(field.name + 'Id')"
                      :options="relationOptions[field.type] || []"
                      option-value="id"
                      option-label="name"
                      emit-value
                      map-options
                      :rules="[val => field.isRequired ? (val !== null && val !== undefined) || 'This field is required' : true]"
                    />
                  </div>
                  
                  <!-- Enum fields -->
                  <div v-else-if="field.isEnum" class="col-12">
                    <q-select
                      v-model="editingItem[field.name]"
                      :label="formatLabel(field.name)"
                      :options="enumOptions[field.type] || []"
                      :rules="[val => field.isRequired ? !!val || 'This field is required' : true]"
                    />
                  </div>
                  
                  <!-- Boolean fields -->
                  <div v-else-if="field.type === 'Boolean'" class="col-12">
                    <q-toggle
                      v-model="editingItem[field.name]"
                      :label="formatLabel(field.name)"
                    />
                  </div>
                  
                  <!-- Date fields -->
                  <div v-else-if="field.type === 'DateTime'" class="col-12">
                    <q-input
                      v-model="editingItem[field.name]"
                      :label="formatLabel(field.name)"
                      type="datetime-local"
                      :rules="[val => field.isRequired ? !!val || 'This field is required' : true]"
                    />
                  </div>
                  
                  <!-- Number fields -->
                  <div v-else-if="['Int', 'Float'].includes(field.type)" class="col-12">
                    <q-input
                      v-model.number="editingItem[field.name]"
                      :label="formatLabel(field.name)"
                      type="number"
                      :rules="[val => field.isRequired ? (val !== null && val !== undefined) || 'This field is required' : true]"
                    />
                  </div>
                  
                  <!-- Default text fields -->
                  <div v-else class="col-12">
                    <q-input
                      v-model="editingItem[field.name]"
                      :label="formatLabel(field.name)"
                      :rules="[val => field.isRequired ? !!val || 'This field is required' : true]"
                    />
                  </div>
                </template>
              </div>
              
              <div class="row justify-end q-mt-md">
                <q-btn label="Cancel" color="negative" flat v-close-popup />
                <q-btn label="Save" type="submit" color="primary" class="q-ml-sm" />
              </div>
            </q-form>
          </q-card-section>
        </q-card>
      </q-dialog>
      
      <!-- Delete Confirmation -->
      <q-dialog v-model="showDeleteConfirm" persistent>
        <q-card>
          <q-card-section class="row items-center">
            <q-avatar icon="delete" color="negative" text-color="white" />
            <span class="q-ml-sm">Are you sure you want to delete this item?</span>
          </q-card-section>
  
          <q-card-actions align="right">
            <q-btn flat label="Cancel" color="primary" v-close-popup />
            <q-btn flat label="Delete" color="negative" @click="deleteItem" v-close-popup />
          </q-card-actions>
        </q-card>
      </q-dialog>
    </div>
  </template>
  
  <script setup>
  import { ref, computed, onMounted, reactive } from 'vue';
  import { useQuasar } from 'quasar';
  import { host } from '../config/api';
  import axios from 'axios';
  import { useUtilizatorStore } from '../stores/useUtilizatorStores'
  
  const props = defineProps({
    modelName: {
      type: String,
      required: true
    },
    apiBasePath: {
      type: String,
      required: true
    },
    // Fields that should be excluded from the form (e.g., 'id', 'createdAt', 'updatedAt')
    excludeFields: {
      type: Array,
      default: () => ['id', 'createdAt', 'updatedAt']
    },
    // Optional overrides for field configurations
    fieldOverrides: {
      type: Object,
      default: () => ({})
    },
    // Optional initial field values
    initialValues: {
      type: Object,
      default: () => ({})
    }
  });
  
  const $q = useQuasar();
  const utilizatorStore = useUtilizatorStore()
  // State
  const loading = ref(false);
  const items = ref([]);
  const modelMetadata = ref(null);
  const enumOptions = ref({});
  const relationOptions = ref({});
  const filter = ref('');
  const pagination = ref({
    sortBy: 'id',
    descending: false,
  //  page: 1,
    rowsPerPage: 10,
  //  rowsNumber: 0
  });
  
  const showDialog = ref(false);
  const showDeleteConfirm = ref(false);
  const editingItem = ref({});
  const itemToDelete = ref(null);
  const itemForm = ref(null);
  
  // Computed properties
  const columns = computed(() => {
    if (!modelMetadata.value) return [];
    
    const cols = modelMetadata.value.properties
      .filter(prop => !props.excludeFields.includes(prop.name))
      .map(prop => ({
        name: prop.name,
        label: formatLabel(prop.name),
        field: row => {
          // Handle relation fields
          if (prop.isRelation && row[prop.name]) {
            return row[prop.name].name;
          }
          return row[prop.name];
        },
        sortable: true,
        align: ['Int', 'Float'].includes(prop.type) ? 'right' : 'left'
      }));
    
    // Add actions column
    cols.push({
      name: 'actions',
      label: 'Actions',
      field: 'actions',
      sortable: false,
      align: 'center'
    });
    
    return cols;
  });
  
  const formFields = computed(() => {
    if (!modelMetadata.value) return [];
    
    return modelMetadata.value.properties
      .filter(prop => !props.excludeFields.includes(prop.name))
      .map(prop => {
        // Apply any field overrides
        const override = props.fieldOverrides[prop.name] || {};
        return { ...prop, ...override };
      });
  });

  // Lifecycle hooks
  onMounted(async () => {
    await fetchModelMetadata();
    await fetchEnumOptions();
    await fetchRelationOptions();
    await fetchItems();
    console.log('formFields', formFields.value);
  });
  
  // Methods
  async function fetchModelMetadata() {
    try {
      loading.value = true;
      //host+'/features/models/Structure'
      const response = await axios.get(`${host}/features/prisma/models/${props.modelName}`);
      modelMetadata.value = response.data;
    } catch (error) {
      console.error('Error fetching model metadata:', error);
      $q.notify({
        type: 'negative',
        message: `Failed to fetch ${props.modelName} metadata`
      });
    } finally {
      loading.value = false;
    }
  }
  
  async function fetchEnumOptions() {
    try {
      if (!modelMetadata.value) return;
      
      const enumTypes = modelMetadata.value.properties
        .filter(prop => isEnumType(prop.type))
        .map(prop => prop.type);
      
      if (enumTypes.length === 0) return;
      
      const response = await axios.get(`${host}/features/prisma/modelenums`);
      const enums = response.data;
      
      enumTypes.forEach(enumType => {
        const enumData = enums.find(e => e.name === enumType);
        if (enumData) {
          enumOptions.value[enumType] = enumData.values;
        }
        console.log('enum options', enumOptions.value);
      });
    } catch (error) {
      console.error('Error fetching enum options:', error);
    }
  }
  
  async function fetchRelationOptions() {
    try {
      if (!modelMetadata.value) return;
      
      const relationFields = modelMetadata.value.properties
        .filter(prop => prop.isRelation);
      
      for (const field of relationFields) {
        const modelName = field.type;
       
       const response = await axios.get(`${props.apiBasePath}/${modelName.toLowerCase()}`);
       relationOptions.value[modelName] = response.data;
       
       console.log('relationOptions', relationOptions.value);
      }
    } catch (error) {
      console.error('Error fetching relation options:', error);
    }
  }
  
  async function fetchItems(params = {}) {
    try {
      loading.value = true;
      
      // Merge pagination state with any provided params
      const queryParams = {
        page: pagination.value.page,
        perPage: pagination.value.rowsPerPage,
        sortBy: pagination.value.sortBy,
        sortDesc: pagination.value.descending,
        filter: filter.value,
        ...params
      };
      
      const response = await axios.get(props.apiBasePath/*, { params: queryParams }*/);
      console.log('response', response.data.data);
      // Handle different API response formats
      if (Array.isArray(response.data.data)) {
        items.value = response.data.data;
        pagination.value.rowsNumber = response.data.length;
      } else if (response.data.data.items && Array.isArray(response.data.data.items)) {
        items.value = response.data.data.items;
        pagination.value.rowsNumber = response.data.data.total || response.data.data.items.length;
      } else {
        items.value = [];
        pagination.value.rowsNumber = 0;
      }
    } catch (error) {
      console.error('Error fetching items:', error);
      $q.notify({
        type: 'negative',
        message: `Failed to fetch ${props.modelName} items`
      });
    } finally {
      loading.value = false;
    }
  }
  
  function openDialog(item = null) {
    if (item) {
      // Edit existing item - make a copy to avoid modifying the original
      editingItem.value = { ...item };
    } else {
      // Create new item
      editingItem.value = { ...props.initialValues };
    }
    
    showDialog.value = true;
  }
  
  async function saveItem() {
    try {
      if (itemForm.value && !await itemForm.value.validate()) {
        return;
      }
      
      loading.value = true;
      const config = {
            headers: {
              Authorization: `Bearer ${utilizatorStore.utilizator?.access_token}`
            }
          };
       let date = new Date();

        // Add 2 hours (2 hours * 60 minutes * 60 seconds * 1000 milliseconds)
        date.setTime(date.getTime() + (2 * 60 * 60 * 1000));
      // Clean the data before sending to backend
      const cleanedData = { ...editingItem.value };
      delete cleanedData.structure;
      delete cleanedData.createdAt;
      delete cleanedData.updatedAt;
      
      if (cleanedData.id) {
        // Update existing item
        await axios.patch(`${props.apiBasePath}/${cleanedData.id}`, {...cleanedData, updatedAt: date},
        config);
        $q.notify({
          type: 'positive',
          message: `${props.modelName} updated successfully`
        });
      } else {
        // Create new item
        await axios.post(props.apiBasePath,  {...cleanedData, updatedAt: date}, config);
        $q.notify({
          type: 'positive',
          message: `${props.modelName} created successfully`
        });
      }
      
      showDialog.value = false;
      await fetchItems();
    } catch (error) {
      console.error('Error saving item:', error);
      $q.notify({
        type: 'negative',
        message: `Failed to save ${props.modelName}: ${error.response?.data?.message || error.message}`
      });
    } finally {
      loading.value = false;
    }
  }
  
  function confirmDelete(item) {
    itemToDelete.value = item;
    showDeleteConfirm.value = true;
  }
  
  async function deleteItem() {
    if (!itemToDelete.value) return;
    
    try {
      loading.value = true;
      await axios.delete(`${props.apiBasePath}/${itemToDelete.value.id}`);
      
      $q.notify({
        type: 'positive',
        message: `${props.modelName} deleted successfully`
      });
      
      await fetchItems();
    } catch (error) {
      console.error('Error deleting item:', error);
      $q.notify({
        type: 'negative',
        message: `Failed to delete ${props.modelName}`
      });
    } finally {
      loading.value = false;
      itemToDelete.value = null;
    }
  }
  
  function onRequest(props) {
    console.log('onRequest', props);
    const { page, rowsPerPage, sortBy, descending } = props.pagination;
    
    pagination.value.page = page;
    pagination.value.rowsPerPage = rowsPerPage;
    pagination.value.sortBy = sortBy;
    pagination.value.descending = descending;
    
    fetchItems();
  }
  
  // Utility functions
  function formatLabel(fieldName) {
    return fieldName
      // Add space before uppercase letters
      .replace(/([A-Z])/g, ' $1')
      // Replace underscores with spaces
      .replace(/_/g, ' ')
      // Capitalize first letter
      .replace(/^./, str => str.toUpperCase())
      // Handle special case for 'Id' suffix
      .replace(/\sId$/, ' ID');
  }
  
  function isEnumType(type) {
    if (!modelMetadata.value) return false;
    // Assuming the isEnum method is exposed via the API
    // Alternative: maintain a list of known enum types
    return ['Availibility', 'Datatypes'].includes(type);
  }
  </script>
</file>

<file path="components/EssentialLink.vue">
<template>
  <q-item
    clickable
    tag="a"
    target="_blank"
    :href="props.link"
  >
    <q-item-section
      v-if="props.icon"
      avatar
    >
      <q-icon :name="props.icon" />
    </q-item-section>

    <q-item-section>
      <q-item-label>{{ props.title }}</q-item-label>
      <q-item-label caption>{{ props.caption }}</q-item-label>
    </q-item-section>
  </q-item>
</template>

<script setup>
const props = defineProps({
  title: {
    type: String,
    required: true
  },

  caption: {
    type: String,
    default: ''
  },

  link: {
    type: String,
    default: '#'
  },

  icon: {
    type: String,
    default: ''
  }
})
</script>
</file>

<file path="components/Meniu.vue">
<template>
    <div class="q-pa-md" style="max-width: 350px">
      <q-list bordered class="rounded-borders">
        <!-- Administrare Section -->
        <q-expansion-item
          expand-separator
          icon="settings"
          label="Administrare"
          header-class="text-primary"
        >
          <q-card>
            <q-card-section>
              <q-list dense>
                <q-item clickable v-ripple to="/utilizatori">
                  <q-item-section>
                    <q-item-label>Utilizatori</q-item-label>
                  </q-item-section>
                </q-item>
                <q-item clickable v-ripple>
                  <q-item-section>
                    <q-item-label>Configurare</q-item-label>
                  </q-item-section>
                </q-item>
              </q-list>
            </q-card-section>
          </q-card>
        </q-expansion-item>
  
        <!-- Casierie Section -->
        <q-expansion-item
          expand-separator
          icon="point_of_sale"
          label="Schema"
          header-class="text-primary"
        >
          <q-card>
            <q-card-section>
              <q-list dense>
                <q-item clickable v-ripple to="/structuri">
                  <q-item-section>
                    <q-item-label>Structuri</q-item-label>
                  </q-item-section>
                </q-item>
                <q-item clickable v-ripple to="/atributestructuri">
                  <q-item-section>
                    <q-item-label>Atribute structuri</q-item-label>
                  </q-item-section>
                </q-item>
                <q-item clickable v-ripple to="/articles">
                  <q-item-section>
                    <q-item-label>Articole</q-item-label>
                  </q-item-section>
                </q-item>
              </q-list>
            </q-card-section>
          </q-card>
        </q-expansion-item>
  
        <!-- Rapoarte Section -->
        <q-expansion-item
          expand-separator
          icon="assessment"
          label="Rapoarte"
          header-class="text-primary"
        >
          <q-card>
            <q-card-section>
              <q-list dense>
                <q-item clickable v-ripple>
                  <q-item-section>
                    <q-item-label>Registru de casa</q-item-label>
                  </q-item-section>
                </q-item>
                <q-item clickable v-ripple>
                  <q-item-section>
                    <q-item-label>Situatie incasari</q-item-label>
                  </q-item-section>
                </q-item>
              </q-list>
            </q-card-section>
          </q-card>
        </q-expansion-item>
      </q-list>
    </div>
  </template>
  
  <script setup>
  // No JavaScript logic needed for this basic menu structure
  // You can add reactive variables, methods, etc. here if needed
  </script>
  
  <style scoped>
  /* Add any custom styles here if needed */
  </style>
</file>

<file path="components/ModelCrudTable.vue">
<template>
  <div class="q-pa-xl">
    <!-- Table with loading state and data display -->
    <q-table
      :rows="items"
      :columns="columns"
      :loading="loading"
      row-key="id"
      flat
      bordered
    >
      <template v-slot:top>
        <div class="row full-width">
          <div class="col-6 q-table__title">{{ props.modelMetadata?.name }}</div>
          <div class="col-6 text-right">
            <q-btn color="primary" icon="add" label="Add New" @click="openCreateDialog" />
          </div>
        </div>
      </template>

      <template v-slot:body="props">
        <q-tr :props="props">
          <q-td v-for="col in columns" :key="col.name" :props="props">
            {{ props.row[col.name] }}
          </q-td>
          <q-td auto-width>
            <q-btn flat round color="primary" icon="edit" @click="openEditDialog(props.row)" />
            <q-btn flat round color="negative" icon="delete" @click="confirmDelete(props.row)" />
          </q-td>
        </q-tr>
      </template>
    </q-table>

    <!-- Create/Edit Dialog -->
    <q-dialog v-model="dialogVisible" persistent>
      <q-card style="min-width: 350px">
        <q-card-section class="row items-center q-pb-none">
          <div class="text-h6">{{ isEditing ? 'Edit' : 'Create' }} {{ props.modelMetadata?.name }}</div>
          <q-space />
          <q-btn icon="close" flat round dense v-close-popup />
        </q-card-section>

        <q-card-section>
          <q-form @submit="handleSubmit" class="q-gutter-md">
            <template v-for="field in props.modelMetadata?.fields" :key="field.name">
                            <!-- Add debugging output -->
                            <!-- <div  class="text-caption">
                              Field: {{ field.name }} -> ({{ field.type }})
                             </div> -->
              <q-input
                v-if="field.type === 'varchar' && !field.isId"
                v-model="formData[field.name]"
                :label="field.name"
                :rules="[
                  val => (field.isRequired ? (val && val.length > 0) || 'This field is required' : true),
                  val => (!field.isUnique || !isDuplicateValue(field.name, val)) || 'This value must be unique'
                ]"
              />
              <q-input
                v-else-if="field.type === 'number' && !field.isId"
                v-model.number="formData[field.name]"
                type="number"
                :label="field.name"
                :rules="[val => (field.isRequired ? val !== null || 'This field is required' : true)]"
              />
              <q-toggle
                v-else-if="field.type === 'boolean' && !field.isId"
                v-model="formData[field.name]"
                :label="field.name"
              />
            </template>

            <div class="row justify-end q-mt-md">
              <q-btn label="Cancel" color="primary" flat v-close-popup />
              <q-btn :label="isEditing ? 'Update' : 'Create'" color="primary" type="submit" />
            </div>
          </q-form>
        </q-card-section>
      </q-card>
    </q-dialog>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, watch } from 'vue'
import { useQuasar } from 'quasar'
import axios from 'axios'
import { useUtilizatorStore } from '../stores/useUtilizatorStores'

interface ModelField {
  name: string
  type: string
  isRequired: boolean
  isUnique: boolean
  isId: boolean
  default: string | null
  extra: string
}

interface ModelMetadata {
  name: string
  fields: ModelField[]
}

const props = defineProps<{
  modelMetadata: ModelMetadata | null
  baseUrl: string
}>()

const $q = useQuasar()
const items = ref<any[]>([])
const loading = ref(true)
const dialogVisible = ref(false)
const isEditing = ref(false)
const currentItem = ref<any>(null)
const formData = ref<any>({})

// Computed columns based on model metadata
const columns = computed(() => {
  if (!props.modelMetadata) return []
  return [
    ...props.modelMetadata.fields.map(field => ({
      name: field.name,
      label: field.name.charAt(0).toUpperCase() + field.name.slice(1),
      field: field.name,
      sortable: true,
      align: 'left'
    })),
    { name: 'actions', label: 'Actions', field: 'actions', align: 'center' }
  ]
})

// Reset form data when dialog closes
watch(dialogVisible, (newVal) => {
  if (!newVal) {
    console.log('Dialog closed')
    formData.value = {}
    currentItem.value = null
    isEditing.value = false
  }
})

// Load items from API
const loadItems = async () => {
  try {
    loading.value = true
    const response = await axios.get(`${props.baseUrl}`)
    items.value = response.data
  } catch (error: any) {
    $q.notify({
      color: 'negative',
      message: `Error loading data: ${error.message}`,
      icon: 'error'
    })
  } finally {
    loading.value = false
  }
}

// Check for duplicate values in unique fields
const isDuplicateValue = (fieldName: string, value: any) => {
  return items.value.some(item => 
    item[fieldName] === value && (!currentItem.value || item.id !== currentItem.value.id)
  )
}

// Dialog handlers
const openCreateDialog = () => {
  // Initialize form data with default values from model metadata
  formData.value = {}
  if (props.modelMetadata?.fields) {
    props.modelMetadata.fields.forEach(field => {
      formData.value[field.name] = field.default ?? null
    })
  }

  isEditing.value = false
  dialogVisible.value = true
}

const openEditDialog = (item: any) => {
  currentItem.value = item
  formData.value = { ...item }
  isEditing.value = true
  dialogVisible.value = true
}

const utilizatorStore = useUtilizatorStore()

// Update the handleSubmit function
const handleSubmit = async () => {
  const cleanedFormData = Object.fromEntries(
    Object.entries(formData.value)
      .filter(([key, value]) => value !== null && key !== 'createdAt')
  );
  
  const config = {
    headers: {
      Authorization: `Bearer ${utilizatorStore.utilizator?.access_token}`
    }
  };
  let date = new Date();

// Add 2 hours (2 hours * 60 minutes * 60 seconds * 1000 milliseconds)
date.setTime(date.getTime() + (2 * 60 * 60 * 1000));
  try {
    if (isEditing.value) {
      await axios.patch(
        `${props.baseUrl}/${currentItem.value.id}`, 
        {...cleanedFormData, updatedAt: date},
        config
      )
    } else {
    //  console.log('Clean Form data:', cleanedFormData)
      await axios.post(props.baseUrl, {...cleanedFormData, updatedAt: date}, config)
    }
    await loadItems()
    dialogVisible.value = false
    $q.notify({
      color: 'positive',
      message: `Item ${isEditing.value ? 'updated' : 'created'} successfully`,
      icon: 'check'
    })
  } catch (error: any) {
    $q.notify({
      color: 'negative',
      message: `Error ${isEditing.value ? 'updating' : 'creating'} item: ${error.message}`,
      icon: 'error'
    })
  }
}

// Update the confirmDelete function
const confirmDelete = (item: any) => {
  $q.dialog({
    title: 'Confirm',
    message: 'Are you sure you want to delete this item?',
    cancel: true,
    persistent: true
  }).onOk(async () => {
    try {
      await axios.delete(`${props.baseUrl}/${item.id}`, {
        headers: {
          Authorization: `Bearer ${utilizatorStore.utilizator?.access_token}`
        }
      })
      await loadItems()
      $q.notify({
        color: 'positive',
        message: 'Item deleted successfully',
        icon: 'check'
      })
    } catch (error: any) {
      $q.notify({
        color: 'negative',
        message: `Error deleting item: ${error.message}`,
        icon: 'error'
      })
    }
  })
}

// Load items on mount
loadItems()
</script>
</file>

<file path="config/api.js">
export const host = 'http://localhost:3334';
</file>

<file path="css/app.scss">
// app global css in SCSS form
</file>

<file path="css/quasar.variables.scss">
// Quasar SCSS (& Sass) Variables
// --------------------------------------------------
// To customize the look and feel of this app, you can override
// the Sass/SCSS variables found in Quasar's source Sass/SCSS files.

// Check documentation for full list of Quasar variables

// Your own variables (that are declared here) and Quasar's own
// ones will be available out of the box in your .vue/.scss/.sass files

// It's highly recommended to change the default colors
// to match your app's branding.
// Tip: Use the "Theme Builder" on Quasar's documentation website.

$primary   : #1976D2;
$secondary : #26A69A;
$accent    : #9C27B0;

$dark      : #1D1D1D;
$dark-page : #121212;

$positive  : #21BA45;
$negative  : #C10015;
$info      : #31CCEC;
$warning   : #F2C037;
</file>

<file path="layouts/MainLayout.vue">
<template>
  <q-layout view="lHh Lpr lFf">
    <q-header elevated>
      <q-toolbar>
        <q-btn
          flat
          dense
          round
          icon="menu"
          aria-label="Menu"
          @click="toggleLeftDrawer"
        />

        <q-toolbar-title>
        StaffHUB
        </q-toolbar-title>

        <div> v 28.02.2025</div>
      </q-toolbar>
    </q-header>

    <q-drawer
      v-model="leftDrawerOpen"
      show-if-above
      bordered
    >
    <DrawerTabs />
    <Meniu v-if="utilizatorStore.eAutentificat"/>
      <q-list v-if="utilizatorStore.eAutentificat">
        <q-item-label
          header
        >
          Essential Links
        </q-item-label>

        <EssentialLink
          v-for="link in linksList"
          :key="link.title"
          v-bind="link"
        />
      </q-list>
    </q-drawer>

    <q-page-container>
      <router-view />
    </q-page-container>
  </q-layout>
</template>

<script setup>
import { ref } from 'vue'
import EssentialLink from 'components/EssentialLink.vue'
import Meniu from 'components/Meniu.vue'
import DrawerTabs from 'components/DrawerTabs.vue'
import { useUtilizatorStore } from 'stores/useUtilizatorStores';
const utilizatorStore = useUtilizatorStore();
const linksList = [
  {
    title: 'Docs',
    caption: 'quasar.dev',
    icon: 'school',
    link: 'https://quasar.dev'
  },
  {
    title: 'Github',
    caption: 'github.com/quasarframework',
    icon: 'code',
    link: 'https://github.com/quasarframework'
  },
  {
    title: 'Discord Chat Channel',
    caption: 'chat.quasar.dev',
    icon: 'chat',
    link: 'https://chat.quasar.dev'
  },
  {
    title: 'Forum',
    caption: 'forum.quasar.dev',
    icon: 'record_voice_over',
    link: 'https://forum.quasar.dev'
  },
  {
    title: 'Twitter',
    caption: '@quasarframework',
    icon: 'rss_feed',
    link: 'https://twitter.quasar.dev'
  },
  {
    title: 'Facebook',
    caption: '@QuasarFramework',
    icon: 'public',
    link: 'https://facebook.quasar.dev'
  },
  {
    title: 'Quasar Awesome',
    caption: 'Community Quasar projects',
    icon: 'favorite',
    link: 'https://awesome.quasar.dev'
  }
]

const leftDrawerOpen = ref(false)

function toggleLeftDrawer () {
  leftDrawerOpen.value = !leftDrawerOpen.value
}
</script>
</file>

<file path="pages/ArticleEditPage.vue">
<template>
    <q-page padding>
      <q-btn
        flat
        round
        dense
        icon="arrow_back"
        :to="isEditMode ? { name: 'ArticleView', params: { id: articleId } } : { name: 'ArticleList' }"
        class="q-mb-md"
        aria-label="Back"
      />
  
      <h1 class="text-h4 q-mb-lg">{{ isEditMode ? 'Edit Article' : 'Create New Article' }}</h1>
  
      <q-spinner v-if="isLoading" size="lg" color="primary" class="q-mt-xl block" />
  
      <q-banner v-else-if="errorLoading" class="bg-negative text-white q-mt-md">
        {{ errorLoading }}
      </q-banner>
  
      <q-form v-else @submit.prevent="saveArticle" class="q-gutter-md">
        <q-input
          filled
          v-model="article.title"
          label="Title *"
          lazy-rules
          :rules="[val => !!val || 'Title is required']"
        />
  
        <q-input
          filled
          v-model="article.category"
          label="Category *"
          lazy-rules
          :rules="[val => !!val || 'Category is required']"
        />
  
        <div class="q-mt-xl">
          <h2 class="text-h6 q-mb-md">Content Items</h2>
  
          <q-card
            v-for="(item, index) in article.content"
            :key="index"
            class="q-mb-md"
            bordered
            flat
          >
            <q-card-section>
              <div class="row items-center justify-between q-mb-sm">
                <div class="text-subtitle2 text-grey-7">
                  Item #{{ index + 1 }}: {{ item.type.charAt(0).toUpperCase() + item.type.slice(1) }}
                </div>
                <div>
                  <q-btn
                    flat dense round icon="arrow_upward"
                    @click="moveContentItem(index, -1)"
                    :disable="index === 0"
                    aria-label="Move item up"
                    class="q-mr-xs"
                  />
                  <q-btn
                    flat dense round icon="arrow_downward"
                    @click="moveContentItem(index, 1)"
                    :disable="index === (article.content?.length ?? 0) - 1"
                    aria-label="Move item down"
                     class="q-mr-xs"
                  />
                  <q-btn
                    flat dense round icon="delete" color="negative"
                    @click="removeContentItem(index)"
                    aria-label="Remove item"
                  />
                </div>
              </div>
  
              <!-- Paragraph Editor -->
              <div v-if="item.type === 'PARAGRAPH'">
                <q-editor
                  v-model="item.html"
                  min-height="5rem"
                  :toolbar="[
                    ['bold', 'italic', 'strike', 'underline'],
                    ['link'],
                    ['unordered', 'ordered'],
                    ['viewsource']
                  ]"
                  placeholder="Enter paragraph content..."
                />
              </div>
  
              <!-- File Editor -->
              <div v-else-if="item.type === 'FILE'" class="q-gutter-sm q-mt-sm">
                 <q-input
                    filled dense
                    v-model="item.name"
                    label="Link Text *"
                    lazy-rules
                    :rules="[val => !!val || 'Link text is required']"
                 />
                 <q-input
                    filled dense
                    v-model="item.url"
                    label="File URL *"
                    type="url"
                    lazy-rules
                    :rules="[
                      val => !!val || 'File URL is required',
                      val => /^https?:\/\/.+/.test(val) || 'Must be a valid URL (http/https)'
                      ]"
                  />
                                   <!-- ADDED Q-Uploader -->
                 <q-uploader
                    :url="uploadUrl"
                    label="Upload File (Max 10MB)"
                    field-name="file"
                    accept=".pdf,.doc,.docx,.xls,.xlsx,.ppt,.pptx,.txt,.zip,.rar,.jpg,.jpeg,.png,.gif"
                    max-file-size="10485760"
                    auto-upload
                    max-files="1"
                    @uploaded="(info) => onFileUploaded(index, info)"
                    @failed="onUploadFailed"
                    class="q-mt-md"
                    style="max-width: 100%"
                    flat
                    bordered
                 >
                    <template v-slot:list="scope">
                        <!-- Custom list display to show only the file -->
                        <q-list separator v-if="scope.files.length > 0">
                            <q-item v-for="file in scope.files" :key="file.__key">
                                <q-item-section>
                                    <q-item-label class="full-width ellipsis">
                                    {{ file.name }}
                                    </q-item-label>
                                    <q-item-label caption>
                                    Status: {{ file.__status }}
                                        <q-spinner color="primary" size="xs" v-if="file.__status === 'uploading'" />
                                    </q-item-label>
                                    <q-item-label caption>
                                    {{ file.__sizeLabel }} / {{ file.__progressLabel }}
                                    </q-item-label>
                                </q-item-section>

                                <q-item-section v-if="file.__img" thumbnail class="gt-xs">
                                    <img :src="file.__img.src">
                                </q-item-section>

                                <q-item-section top side>
                                    <q-btn
                                    class="gt-xs"
                                    size="12px"
                                    flat
                                    dense
                                    round
                                    icon="delete"
                                    @click="scope.removeFile(file); clearFileUrl(index)"
                                    />
                                </q-item-section>
                            </q-item>
                        </q-list>
                         <div v-else class="text-center q-pa-md text-grey-7">
                            Drop file here or click to browse
                        </div>
                    </template>
                 </q-uploader>
                 <!-- END of Q-Uploader -->
              </div>
  
                            <!-- Image Editor -->
               <div v-else-if="item.type === 'IMAGE'" class="q-gutter-sm q-mt-sm">
                  <q-input
                    filled dense
                    v-model="item.src"
                    label="Image URL *"
                    type="url"
                    lazy-rules
                    :rules="[
                      val => !!val || 'Image URL is required',
                      val => /^https?:\/\/.+/.test(val) || 'Must be a valid URL (http/https)'
                      ]"
                    hint="Enter URL directly or upload an image below" 
                  />
                  <q-input
                    filled dense
                    v-model="item.alt"
                    label="Alt Text *"
                    lazy-rules
                    :rules="[val => !!val || 'Alt text is required for accessibility']"
                 />
                 <img
                   v-if="item.src && /^https?:\/\/.+/.test(item.src)" 
                   :src="item.src"
                   :alt="item.alt || 'Image Preview'"
                   class="q-mt-sm"
                   style="max-width: 200px; max-height: 150px; display: block; border: 1px solid #ccc;"
                  />

                 <!-- ADDED Q-Uploader for Images -->
                 <q-uploader
                    :url="uploadUrl"
                    label="Upload Image (Max 10MB)"
                    field-name="file"
                    accept="image/*,.jpeg,.jpg,.png,.gif,.webp,.svg" 
                    max-file-size="10485760"
                    auto-upload
                    max-files="1"
                    @uploaded="(info) => onImageUploaded(index, info)" 
                    @failed="onUploadFailed" 
                    class="q-mt-md"
                    style="max-width: 100%"
                    flat
                    bordered
                 >
                    <template v-slot:list="scope">
                        <q-list separator v-if="scope.files.length > 0">
                            <q-item v-for="file in scope.files" :key="file.__key">
                                <q-item-section>
                                    <q-item-label class="full-width ellipsis"> {{ file.name }} </q-item-label>
                                    <q-item-label caption> Status: {{ file.__status }}
                                        <q-spinner color="primary" size="xs" v-if="file.__status === 'uploading'" />
                                    </q-item-label>
                                    <q-item-label caption> {{ file.__sizeLabel }} / {{ file.__progressLabel }} </q-item-label>
                                </q-item-section>
                                <q-item-section v-if="file.__img" thumbnail class="gt-xs">
                                    <img :src="file.__img.src"> <!-- Uploader's internal preview -->
                                </q-item-section>
                                <q-item-section top side>
                                    <q-btn class="gt-xs" size="12px" flat dense round icon="delete"
                                        @click="scope.removeFile(file); clearImageUrl(index)" /> <!-- NEW clear handler -->
                                </q-item-section>
                            </q-item>
                        </q-list>
                         <div v-else class="text-center q-pa-md text-grey-7"> Drop image here or click to browse </div>
                    </template>
                 </q-uploader>
                 <!-- END of Q-Uploader for Images -->

              </div>
            </q-card-section>
          </q-card>
  
          <q-banner v-if="!article.content || article.content.length === 0" class="bg-grey-2 q-mb-md">
            No content items added yet. Use the buttons below to add content.
          </q-banner>
  
          <div class="q-mt-md q-gutter-sm">
            <q-btn outline color="primary" icon="notes" label="Add Paragraph" @click="addContentItem('PARAGRAPH')" />
            <q-btn outline color="primary" icon="attachment" label="Add File Link" @click="addContentItem('FILE')" />
            <q-btn outline color="primary" icon="image" label="Add Image" @click="addContentItem('IMAGE')" />
          </div>
        </div>
  
        <q-separator class="q-my-lg" />
  
        <div>
          <q-btn label="Save Article" type="submit" color="primary" :loading="isSaving" />
          <q-btn
            label="Cancel"
            type="button"
            color="grey"
            flat
            class="q-ml-sm"
            :to="isEditMode ? { name: 'ArticleView', params: { id: articleId } } : { name: 'ArticleList' }"
          />
        </div>
      </q-form>
  
    </q-page>
  </template>
  
  <script setup lang="ts">
  import { ref, reactive, onMounted, computed } from 'vue';
  import { useRouter } from 'vue-router';
  import { useQuasar, QForm } from 'quasar';
  import { ArticleService } from 'src/services/ArticleService';
  import { host } from '../config/api';
  import { ArticleInput, ContentItem, ParagraphItem, FileItem, ImageItem } from 'src/types/models';
  
  interface Props {
    id?: string | number; // Optional prop for edit mode
  }
  const props = defineProps<Props>();
  
  const $q = useQuasar();
  const router = useRouter();
  
  // Use reactive for the form object
  const article = reactive<ArticleInput>({
    title: '',
    category: '',
    content: [],
  });
  const API_BASE_URL = host; // Use env variable
const uploadUrl = computed(() => `${API_BASE_URL}/upload/single`); // Make it computed
  const isLoading = ref(false);
  const isSaving = ref(false);
  const errorLoading = ref<string | null>(null);
  
  const articleId = computed(() => props.id ? Number(props.id) : null);
  const isEditMode = computed(() => articleId.value !== null && !isNaN(articleId.value));
  
  const fetchArticleForEdit = async () => {
    if (!isEditMode.value || articleId.value === null) return;
  
    isLoading.value = true;
    errorLoading.value = null;
    try {
      const fetchedArticle = await ArticleService.getArticleById(articleId.value);
      // Use Object.assign or spread to update the reactive object properties
      Object.assign(article, fetchedArticle);
      // Ensure content is always an array
       if (!article.content) {
        article.content = [];
      }
    } catch (error) {
      console.error(`Failed to fetch article ${articleId.value} for editing:`, error);
      errorLoading.value = 'Could not load the article data for editing.';
       $q.notify({ color: 'negative', message: errorLoading.value });
       // Optionally redirect back if loading failed critically
       // router.push({ name: 'ArticleList' });
    } finally {
      isLoading.value = false;
    }
  };
  
  const addContentItem = (type: ContentItem['type']) => {
    let newItem: ContentItem;
    switch (type) {
      case 'PARAGRAPH':
        newItem = { type: 'PARAGRAPH', html: '' };
        break;
      case 'FILE':
        newItem = { type: 'FILE', url: '', name: '' };
        break;
      case 'IMAGE':
        newItem = { type: 'IMAGE', src: '', alt: '' };
        break;
      default:
        // Should not happen with defined types
        console.error('Unknown content type:', type);
        return;
    }
     if (!article.content) {
      article.content = []; // Initialize if null/undefined
     }
    article.content.push(newItem);
  };
  
  const removeContentItem = (index: number) => {
    if (article.content) {
      article.content.splice(index, 1);
    }
  };
  
  const moveContentItem = (index: number, direction: number) => {
    if (!article.content) return;
  
    const newIndex = index + direction;
    if (newIndex < 0 || newIndex >= article.content.length) {
      return; // Out of bounds
    }
  
    // Simple swap
    const itemToMove = article.content[index];
    article.content[index] = article.content[newIndex];
    article.content[newIndex] = itemToMove;
  
    // Alternative using splice for clarity
    // const [item] = article.content.splice(index, 1);
    // article.content.splice(newIndex, 0, item);
  };
  
  const saveArticle = async () => {
    isSaving.value = true;
    // QForm handles validation triggering on submit, but manual check can be added
    if (!article.title || !article.category) {
        $q.notify({ color: 'warning', message: 'Please fill in Title and Category.' });
        isSaving.value = false;
        return;
    }
  
    try {
      let savedArticle;
      // Create a deep copy of content items, remove 'id' and 'articleId' properties,
      // and ensure each item has a unique 'order' value
      const contentWithoutIds = article.content ? article.content.map((item, index) => {
        const { id, articleId, ...itemWithoutIds } = item as any;
        // Add explicit order property based on index
        return {
          ...itemWithoutIds,
          order: index // Ensure unique order values
        };
      }) : [];

      const payload: ArticleInput = {
        title: article.title,
        category: article.category,
        content: contentWithoutIds
      };
  
      if (isEditMode.value && articleId.value) {
        savedArticle = await ArticleService.updateArticle(articleId.value, payload);
        $q.notify({ color: 'positive', message: 'Article updated successfully!' });
        router.push({ name: 'ArticleView', params: { id: savedArticle.id } });
      } else {
        savedArticle = await ArticleService.createArticle(payload);
        $q.notify({ color: 'positive', message: 'Article created successfully!' });
        router.push({ name: 'ArticleView', params: { id: savedArticle.id } });
      }
  
    } catch (error) {
      console.error('Failed to save article:', error);
      $q.notify({
        color: 'negative',
        message: `Failed to save article. ${ (error as Error).message || 'Please try again.'}`
      });
    } finally {
      isSaving.value = false;
    }
  };
  
  onMounted(() => {
     if (isEditMode.value) {
      fetchArticleForEdit();
    } else {
       // Reset for 'new' mode (though reactive default covers this)
       Object.assign(article, { title: '', category: '', content: [] });
     }
  });
  // --- Uploader Event Handlers ---

// Type the 'info' parameter for better DX
// info has structure { files: File[], xhr: XMLHttpRequest }
const onFileUploaded = (index: number, info: { files: File[], xhr: XMLHttpRequest }) => {
  try {
    const response = JSON.parse(info.xhr.responseText);
    const fileUrl = response?.url; // Access the URL from backend response

    if (fileUrl && article.content && article.content[index]?.type === 'FILE') {
        // Explicitly cast to FileItem if needed, or ensure type guard
        const fileItem = article.content[index] as FileItem;
        fileItem.url = fileUrl;

      // Optionally prefill link text with original file name if empty
      if (!fileItem.name && info.files.length > 0) {
        fileItem.name = info.files[0].name.split('.').slice(0, -1).join('.'); // Remove extension
      }

      $q.notify({
        color: 'positive',
        message: `File ${info.files[0].name} uploaded successfully. URL updated.`,
        icon: 'check',
      });

      // Optional: remove the file from uploader display after successful upload handled
      // This requires accessing the uploader instance via ref, which is tricky in v-for
      // Simpler to let the user remove it manually via the uploader's UI if needed.

    } else {
       console.error('Failed to parse URL from upload response or item type mismatch:', response);
       $q.notify({ color: 'negative', message: 'Error processing upload response.' });
    }
  } catch (e) {
    console.error('Error parsing upload response:', e, info.xhr.responseText);
    $q.notify({ color: 'negative', message: 'Failed to read server response after upload.' });
  }
};

const onUploadFailed = (info: { files: File[], xhr: XMLHttpRequest }) => {
    // Check for specific error messages from backend if available
    let errorMsg = 'File upload failed.';
    try {
        const response = JSON.parse(info.xhr.responseText);
        if (response?.message) {
            errorMsg = `File upload failed: ${response.message}`;
        }
    } catch (e) {
        // Ignore if response is not JSON
    }

    $q.notify({
        color: 'negative',
        message: errorMsg,
        icon: 'warning',
    });
};

// Optional: Function to clear URL if user removes file from uploader
const clearFileUrl = (index: number) => {
    if (article.content && article.content[index]?.type === 'FILE') {
        const fileItem = article.content[index] as FileItem;
        // Only clear if maybe it matches a filename pattern? Or just always clear?
        // Let's clear it. User can re-paste if needed.
        fileItem.url = '';
         $q.notify({
            color: 'info',
            message: 'File removed from uploader. URL cleared.',
            icon: 'info',
            position: 'top-right' // Avoid covering uploader
        });
    }
};

// NEW Handler for IMAGE upload
const onImageUploaded = (index: number, info: { files: File[], xhr: XMLHttpRequest }) => {
  try {
    const response = JSON.parse(info.xhr.responseText);
    const imageUrl = response?.url; // Get URL from backend response

    if (imageUrl && article.content && article.content[index]?.type === 'IMAGE') {
        // Cast to ImageItem for type safety
        const imageItem = article.content[index] as ImageItem;
        imageItem.src = imageUrl; // Update the 'src' field

      // We don't automatically fill alt text here, it should be descriptive
      // if (!imageItem.alt && info.files.length > 0) {
      //   imageItem.alt = info.files[0].name.split('.').slice(0, -1).join('.'); // Avoid doing this
      // }

      $q.notify({
        color: 'positive',
        message: `Image ${info.files[0].name} uploaded successfully. URL updated.`,
        icon: 'check',
      });

    } else {
       console.error('Failed to parse URL from upload response or item type mismatch for IMAGE:', response);
       $q.notify({ color: 'negative', message: 'Error processing image upload response.' });
    }
  } catch (e) {
    console.error('Error parsing image upload response:', e, info.xhr.responseText);
    $q.notify({ color: 'negative', message: 'Failed to read server response after image upload.' });
  }
};

// NEW Handler to clear IMAGE URL
const clearImageUrl = (index: number) => {
    if (article.content && article.content[index]?.type === 'IMAGE') {
        (article.content[index] as ImageItem).src = ''; // Clear the src field
         $q.notify({
            color: 'info', message: 'Image removed from uploader. URL cleared.', icon: 'info', position: 'top-right'
        });
    }
};
  </script>
  
  <style scoped>
  .text-h4 {
    margin-top: 0;
  }
  /* Add specific styles if needed */
  </style>
</file>

<file path="pages/ArticleListPage.vue">
<template>
    <q-page padding>
      <q-tabs
        v-model="activeTab"
        class="text-primary q-mb-md"
        indicator-color="primary"
        align="left"
      >
        <q-tab name="design" label="Design" />
        <q-tab name="preview" label="Preview" />
      </q-tabs>

      <q-tab-panels v-model="activeTab" animated>
        <q-tab-panel name="design">
          <div class="row justify-between items-center q-mb-md">
            <div class="text-h4">Articles</div>
            <q-btn
              color="primary"
              icon="add"
              label="Create Article"
              :to="{ name: 'ArticleCreate' }"
            />
          </div>
      
          <q-spinner v-if="isLoading" size="lg" color="primary" class="q-mt-xl" />
      
          <q-table
            v-else-if="articles.length > 0"
            :rows="articles"
            :columns="columns"
            row-key="id"
            flat
            bordered
            class="q-mt-md"
          >
            <template v-slot:body-cell-actions="props">
              <q-td :props="props">
                <q-btn
                  flat
                  dense
                  round
                  icon="visibility"
                  color="info"
                  :to="{ name: 'ArticleView', params: { id: props.row.id } }"
                  class="q-mr-sm"
                />
                <q-btn
                  flat
                  dense
                  round
                  icon="edit"
                  color="primary"
                  :to="{ name: 'ArticleEdit', params: { id: props.row.id } }"
                  class="q-mr-sm"
                />
                <q-btn
                  flat
                  dense
                  round
                  icon="delete"
                  color="negative"
                  @click="confirmDeleteArticle(props.row.id, props.row.title)"
                />
              </q-td>
            </template>
          </q-table>
      
          <q-banner v-else class="bg-grey-3 q-mt-md">
            No articles found. Create one to get started!
          </q-banner>
        </q-tab-panel>

        <q-tab-panel name="preview">
          <div class="text-h4 q-mb-md">Preview</div>
          <BlogView :api-url="`${host}/articles`" />
        </q-tab-panel>
      </q-tab-panels>
    </q-page>
  </template>
  
  <script setup lang="ts">
  import { ref, onMounted } from 'vue';
  import { useRouter } from 'vue-router';
  import { useQuasar, QTableColumn } from 'quasar';
  import { ArticleService } from 'src/services/ArticleService';
  import { Article } from '../types/models';
  import BlogView from '../components/BlogView.vue';
  import { host } from '../config/api';
  
  const $q = useQuasar();
  const router = useRouter(); // Use router if needed, though <router-link>/:to is often simpler
  
  const activeTab = ref('design'); // Default active tab
  const articles = ref<Article[]>([]);
  const isLoading = ref(false);
  
  const columns: QTableColumn[] = [
    { name: 'title', label: 'Title', field: 'title', align: 'left', sortable: true },
    { name: 'category', label: 'Category', field: 'category', align: 'left', sortable: true },
    { name: 'actions', label: 'Actions', field: 'id', align: 'right' },
  ];
  
  const fetchArticles = async () => {
    isLoading.value = true;
    try {
      articles.value = await ArticleService.getArticles();
    } catch (error) {
      console.error('Failed to fetch articles:', error);
      $q.notify({
        color: 'negative',
        icon: 'error',
        message: 'Could not load articles. Please try again later.',
      });
    } finally {
      isLoading.value = false;
    }
  };
  
  const confirmDeleteArticle = (id: number, title: string) => {
    $q.dialog({
      title: 'Confirm Delete',
      message: `Are you sure you want to delete the article "${title}"? This action cannot be undone.`,
      cancel: true,
      persistent: true,
      ok: {
        label: 'Delete',
        color: 'negative',
      },
    }).onOk(async () => {
      await deleteArticle(id);
    });
  };
  
  const deleteArticle = async (id: number) => {
    console.log(`Deleting article ${id}`); // Add this line to check if the function is being called
  //  $q.loading.show({ message: 'Deleting article...' });
    try {
      await ArticleService.deleteArticle(id);
      $q.notify({
        color: 'positive',
        icon: 'check_circle',
        message: 'Article deleted successfully.',
      });
      // Refresh the list
      await fetchArticles();
    } catch (error) {
      console.error(`Failed to delete article ${id}:`, error);
      $q.notify({
        color: 'negative',
        icon: 'error',
        message: 'Failed to delete article. Please try again.',
      });
    } finally {
     //$q.loading.hide();
    }
  };
  
  onMounted(() => {
    fetchArticles();
  });
  </script>
  
  <style scoped>
  .text-h4 {
    margin: 0;
  }
  </style>
</file>

<file path="pages/ArticleViewPage.vue">
<template>
    <q-page padding>
      <q-btn
        flat
        round
        dense
        icon="arrow_back"
        :to="{ name: 'ArticleList' }"
        class="q-mb-md"
        aria-label="Back to list"
      />
  
      <q-spinner v-if="isLoading" size="lg" color="primary" class="q-mt-xl block" />
  
      <q-banner v-else-if="errorLoading" class="bg-negative text-white q-mt-md">
        {{ errorLoading }}
      </q-banner>
  
      <article v-else-if="article">
        <h1 class="text-h3 q-mb-sm">{{ article.title }}</h1>
        <p class="text-subtitle1 text-grey-7 q-mb-lg">Category: {{ article.category }}</p>
  
        <q-btn
            color="primary"
            icon="edit"
            label="Edit Article"
            :to="{ name: 'ArticleEdit', params: { id: article.id } }"
            class="q-mb-lg"
          />
  
        <div class="article-content">
          <div
            v-for="(item, index) in article.content"
            :key="index"
            class="content-item q-mb-md"
          >
            <!-- Paragraph -->
            <div v-if="item.type === 'paragraph'" v-html="item.html"></div>
  
            <!-- File -->
            <div v-else-if="item.type === 'file'">
              <q-icon name="attachment" size="xs" class="q-mr-xs" />
              <a :href="item.url" target="_blank" rel="noopener noreferrer">{{ item.name }}</a>
            </div>
  
            <!-- Image -->
            <div v-else-if="item.type === 'image'">
              <img :src="item.src" :alt="item.alt" class="responsive-image q-my-md" />
            </div>
          </div>
        </div>
  
      </article>
  
      <q-banner v-else class="bg-grey-3 q-mt-md">
        Article not found.
      </q-banner>
  
    </q-page>
  </template>
  
  <script setup lang="ts">
  import { ref, onMounted } from 'vue';
  import { useQuasar } from 'quasar';
  import { ArticleService } from 'src/services/ArticleService';
  import { Article } from 'src/types/models';
  
  interface Props {
    id: string | number; // Route param comes as string initially
  }
  const props = defineProps<Props>();
  
  const $q = useQuasar();
  const article = ref<Article | null>(null);
  const isLoading = ref(false);
  const errorLoading = ref<string | null>(null);
  
  const fetchArticle = async () => {
    isLoading.value = true;
    errorLoading.value = null;
    const articleId = Number(props.id);
  
    if (isNaN(articleId)) {
      errorLoading.value = 'Invalid article ID.';
      isLoading.value = false;
      return;
    }
  
    try {
      article.value = await ArticleService.getArticleById(articleId);
    } catch (error) {
      console.error(`Failed to fetch article ${articleId}:`, error);
      errorLoading.value = 'Could not load the article. It might not exist or there was a network issue.';
      $q.notify({
        color: 'negative',
        icon: 'error',
        message: errorLoading.value,
      });
    } finally {
      isLoading.value = false;
    }
  };
  
  onMounted(() => {
    fetchArticle();
  });
  </script>
  
  <style scoped>
  .article-content {
    max-width: 800px; /* Adjust as needed */
    margin: 0 auto; /* Center content */
  }
  
  .content-item {
    line-height: 1.6;
  }
  
  /* Style paragraphs rendered via v-html */
  .content-item :deep(p) {
    margin-bottom: 1em;
  }
  .content-item :deep(b),
  .content-item :deep(strong) {
    font-weight: bold;
  }
  /* Add more styles for v-html content as needed */
  
  .responsive-image {
    max-width: 100%;
    height: auto;
    display: block;
    border-radius: 4px; /* Optional: slight rounding */
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); /* Optional: subtle shadow */
  }
  
  .text-h3 {
    margin-top: 0;
  }
  </style>
</file>

<file path="pages/AtributeStructuri.vue">
<template>
    <q-page padding>
      <dynamic-crud
        modelName="StructureAttributes"
        :apiBasePath="apiBasePath"
        :excludeFields="['id', 'structureId','createdAt', 'updatedAt']"
        :fieldOverrides="fieldOverrides"
        :initialValues="initialValues"
      />
    </q-page>
  </template>
  
  <script setup>
  import { ref, onMounted } from 'vue';
  import { host } from '../config/api';

  import { useUtilizatorStore } from 'stores/useUtilizatorStores'
  import { useRouter } from 'vue-router'
  import DynamicCrud from 'components/DynamicCrud.vue';
  

  const router = useRouter()
const utilizatorStore = useUtilizatorStore()

if (!utilizatorStore.eAutentificat) {
  router.push('/')
}

  const fieldOverrides = {
    // Override field configurations if needed
    attributeValue: {
      type: 'String',
      isRequired: true,
      // Additional validations or configurations
    }
  };
  
  const initialValues = ref({
    status: 'active',
    datatype: 'TEXT'
  });
  
  const apiBasePath = host + '/structure-attributes';
  // You can also fetch any additional data needed for this specific model
  onMounted(async () => {
    try {
      // Example: fetch any additional data needed for this model
      // const response = await axios.get('/api/some-endpoint');
      // Do something with the response
    } catch (error) {
      console.error('Error fetching additional data:', error);
    }
  });
  </script>
</file>

<file path="pages/ErrorNotFound.vue">
<template>
  <div class="fullscreen bg-blue text-white text-center q-pa-md flex flex-center">
    <div>
      <div style="font-size: 30vh">
        404
      </div>

      <div class="text-h2" style="opacity:.4">
        Oops. Nothing here...
      </div>

      <q-btn
        class="q-mt-xl"
        color="white"
        text-color="blue"
        unelevated
        to="/"
        label="Go Home"
        no-caps
      />
    </div>
  </div>
</template>

<script setup>
//
</script>
</file>

<file path="pages/IndexPage.vue">
<template>
  <q-page class="flex flex-center">
    <img
      alt="Quasar logo"
      src="~assets/quasar-logo-vertical.svg"
      style="width: 200px; height: 200px"
    >
  </q-page>
</template>

<script setup>
//
</script>
</file>

<file path="pages/Structuri.vue">
<template>
  <div class="q-pa-md">
    <div class="text-h6 q-mb-md">Structuri</div>
    <model-crud-table
      v-if="modelMetadata"
      :model-metadata="modelMetadata"
      :base-url="`${host}/structure`"
    />
    <div v-else-if="error" class="text-negative">
      {{ error }}
    </div>
    <div v-else class="text-center">
      <q-spinner-dots size="40px" color="primary" />
      <div class="q-mt-sm">Loading model metadata...</div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useRouter } from 'vue-router'
import axios from 'axios'
import { host } from '../config/api';
import ModelCrudTable from 'components/ModelCrudTable.vue'
import { useUtilizatorStore } from 'stores/useUtilizatorStores'

const router = useRouter()
const utilizatorStore = useUtilizatorStore()

if (!utilizatorStore.eAutentificat) {
  router.push('/')
}

interface ModelField {
  name: string;
  type: string;
  isRequired: boolean;
  isUnique: boolean;
  isId: boolean;
  default: string | null;
  extra: string;
}

interface ModelMetadata {
  name: string;
  fields: ModelField[];
}

const modelMetadata = ref<ModelMetadata | null>(null)
const error = ref<string | null>(null)

onMounted(async () => {
  try {
    const response = await axios.get(host+'/features/models/Structure')
    modelMetadata.value = response.data
  } catch (err: any) {
    error.value = err.message
    console.error('Error fetching model metadata:', err)
  }
})
</script>
</file>

<file path="pages/Utilizatori.vue">
<template>
    <div class="text-h5">Utilizatori</div>
</template>
</file>

<file path="router/index.js">
import { defineRouter } from '#q-app/wrappers'
import { createRouter, createMemoryHistory, createWebHistory, createWebHashHistory } from 'vue-router'
import routes from './routes'

/*
 * If not building with SSR mode, you can
 * directly export the Router instantiation;
 *
 * The function below can be async too; either use
 * async/await or return a Promise which resolves
 * with the Router instance.
 */

export default defineRouter(function (/* { store, ssrContext } */) {
  const createHistory = process.env.SERVER
    ? createMemoryHistory
    : (process.env.VUE_ROUTER_MODE === 'history' ? createWebHistory : createWebHashHistory)

  const Router = createRouter({
    scrollBehavior: () => ({ left: 0, top: 0 }),
    routes,

    // Leave this as is and make changes in quasar.conf.js instead!
    // quasar.conf.js -> build -> vueRouterMode
    // quasar.conf.js -> build -> publicPath
    history: createHistory(process.env.VUE_ROUTER_BASE)
  })

  return Router
})
</file>

<file path="router/routes.js">
const routes = [
  {
    path: '/',
    component: () => import('layouts/MainLayout.vue'),
    children: [
      { path: '', component: () => import('pages/IndexPage.vue') },
      { path: 'utilizatori', component: () => import('pages/Utilizatori.vue') },
      { path: 'structuri', component: () => import('pages/Structuri.vue') },
      { path: 'atributestructuri', component: () => import('pages/AtributeStructuri.vue') },
      {
        path: 'articles',
        name: 'ArticleList',
        component: () => import('pages/ArticleListPage.vue'),
      },
      {
        path: 'articles/new',
        name: 'ArticleCreate',
        component: () => import('src/pages/ArticleEditPage.vue'),
      },
      {
        path: 'articles/:id',
        name: 'ArticleView',
        component: () => import('pages/ArticleViewPage.vue'),
        props: true, // Pass route params as props
      },
      {
        path: 'articles/:id/edit',
        name: 'ArticleEdit',
        component: () => import('src/pages/ArticleEditPage.vue'),
        props: true, // Pass route params as props
      },
    ]
  },

  // Always leave this as last one,
  // but you can also remove it
  {
    path: '/:catchAll(.*)*',
    component: () => import('pages/ErrorNotFound.vue')
  }
]

export default routes
</file>

<file path="services/ArticleService.ts">
// src/services/ArticleService.ts
import { api } from 'boot/axios'; // Import configured Axios instance
import { Article, ArticleInput } from 'src/types/models';
import { host } from '../config/api';
import { useUtilizatorStore } from '../stores/useUtilizatorStores'

const API_ENDPOINT = host+'/articles';
const utilizatorStore = useUtilizatorStore()
const config = {
  headers: {
    Authorization: `Bearer ${utilizatorStore.utilizator?.access_token}`
  }
};
export const ArticleService = {
  async getArticles(): Promise<Article[]> {
    const response = await api.get<Article[]>(API_ENDPOINT);
    return response.data;
  },

  async getArticleById(id: number): Promise<Article> {
    const response = await api.get<Article>(`${API_ENDPOINT}/${id}`);
    return response.data;
  },

  async createArticle(articleData: ArticleInput): Promise<Article> {
    // Format content for Prisma's expected structure and add order field
    const payload = { 
      ...articleData, 
      content: articleData.content ? {
        create: articleData.content.map((item, index) => ({
          ...item,
          order: index // Add the order field based on the array index
        }))
      } : undefined 
    };
    const response = await api.post<Article>(API_ENDPOINT, payload, config);
    return response.data;
  },

  async updateArticle(id: number, articleData: ArticleInput): Promise<Article> {
    // Format content for Prisma's expected structure and add order field
    const payload = { 
      ...articleData, 
      content: articleData.content ? {
        create: articleData.content.map((item, index) => ({
          ...item,
          order: index // Add the order field based on the array index
        }))
      } : undefined 
    };
    const response = await api.patch<Article>(`${API_ENDPOINT}/${id}`, payload, config);
    return response.data;
  },

  async deleteArticle(id: number): Promise<void> {
    await api.delete(`${API_ENDPOINT}/${id}`, config);
  },
};
</file>

<file path="stores/index.js">
import { defineStore } from '#q-app/wrappers'
import { createPinia } from 'pinia'

/*
 * If not building with SSR mode, you can
 * directly export the Store instantiation;
 *
 * The function below can be async too; either use
 * async/await or return a Promise which resolves
 * with the Store instance.
 */

export default defineStore((/* { ssrContext } */) => {
  const pinia = createPinia()

  // You can add Pinia plugins here
  // pinia.use(SomePiniaPlugin)

  return pinia
})
</file>

<file path="stores/useUtilizatorStores.js">
import { defineStore, acceptHMRUpdate } from 'pinia'
import { ref } from 'vue';
export const useUtilizatorStore = defineStore('utilizatorStore',()=>{
  const text="Pinia..."
  const utilizator=ref(null)
  const institutie=ref(null)
  const eAutentificat=ref(false)
  const eAdmin=ref(false)


 async function autentificare(payload){
      console.log('payload autentificare',payload)
      utilizator.value=payload
      eAutentificat.value=true
    //  eAdmin.value = payload.role==='ADMIN'
   //   if(payload.role=='RESPONSABIL') utilizator.value.compartiment = await $fetch('/api/compartimente/'+payload.id)
  }
  
  function asigneazaInstitutie(payload){
      institutie.value=payload
  }

  function logout(){
     console.log('out')
     eAutentificat.value=false
     utilizator.value=null
     institutie.value=null
     eAdmin.value=false;
  }
  return {
      text,
      utilizator,
      eAdmin,
      eAutentificat,
      institutie,
      autentificare,
      logout,
      asigneazaInstitutie
  }
})

if (import.meta.hot) {
  import.meta.hot.accept(acceptHMRUpdate(useUtilizatorStore, import.meta.hot))
}
</file>

<file path="types/models.ts">
// src/types/models.ts

export interface ParagraphItem {
    type: 'PARAGRAPH';
    html: string;
  }
  
  export interface FileItem {
    type: 'FILE';
    url: string;
    name: string;
  }
  
  export interface ImageItem {
    type: 'IMAGE';
    src: string;
    alt: string;
  }
  
  // Union type for content items
  export type ContentItem = ParagraphItem | FileItem | ImageItem;
  
  export interface Article {
    id: number;
    title: string;
    category: string;
    updatedAt: string; // Added updatedAt property
    content: ContentItem[];
  }
  
  // For creating/editing, ID might not be present initially
  export type ArticleInput = Omit<Article, 'id'> & { id?: number };
</file>

<file path="App.vue">
<template>
  <router-view />
</template>

<script setup>
//
</script>
</file>

</files>
